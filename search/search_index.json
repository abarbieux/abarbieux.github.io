{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to KiloGuide Presentation This guide aims to help you to learn how to use kilobots . It has been created for anyone interested in kilobots and swarm robotics , novice or expert. About Kilobots Kilobots are small, minimalist and cheap robots designed by a team from the university of Harvard. They are equiped with all the necessary components to implement swarm behaviors. Organisation ( modified by Arthur) This guide is divided in four sections . The guides aim to explain you basic kilobots operations, such as \"transferring code to the kilobot\", \"calibrating the kilobot\" or \"using Kilo-GUI\". This part also contain the explaination of how use an kilobot emulator. The tutorials focus on the implementation part. With tutorials, you will learn how to code for the kilobot through easy and diverse projects. The argos3 focus on the argos implementation part. With tutorials, you will leanr how to code for the kilobot by using Argos3. The kilombo actually empty is reserved for adding tutorial to leanr how to use Kilombo. If you haven't used kilobots yet, you should probably start by reading the getting-started guide . Resources and troubleshooting There are a few important resources available online about kilobots. This guide has been designed has a minimalist introduction to kilobots and swarm robotics. Therefore, if you want to dive deeper in the kilobot universe or have experienced a problem during your learning process, you should check the following websites : The kilobotics website The kilobot library The kilolib source code A \"getting started\" wiki for kilobots Kilobot's user manual The Harvard's Self-Organizing Research Group Repository Kilombo github (added by Arthur) Argos3 github ( added by Arthur) Authors and contact This guide has been written by Simon Lejoly and completed by Barbieux Arthur. It is part of a project commanded by the university of Namur . Note This guide is not an official guide from the kilobot team or K-Team. To find appropriate support, please visit the links listed above.","title":"Home"},{"location":"index.html#welcome-to-kiloguide","text":"","title":"Welcome to KiloGuide"},{"location":"index.html#presentation","text":"This guide aims to help you to learn how to use kilobots . It has been created for anyone interested in kilobots and swarm robotics , novice or expert.","title":"Presentation"},{"location":"index.html#about-kilobots","text":"Kilobots are small, minimalist and cheap robots designed by a team from the university of Harvard. They are equiped with all the necessary components to implement swarm behaviors.","title":"About Kilobots"},{"location":"index.html#organisation-modified-by-arthur","text":"This guide is divided in four sections . The guides aim to explain you basic kilobots operations, such as \"transferring code to the kilobot\", \"calibrating the kilobot\" or \"using Kilo-GUI\". This part also contain the explaination of how use an kilobot emulator. The tutorials focus on the implementation part. With tutorials, you will learn how to code for the kilobot through easy and diverse projects. The argos3 focus on the argos implementation part. With tutorials, you will leanr how to code for the kilobot by using Argos3. The kilombo actually empty is reserved for adding tutorial to leanr how to use Kilombo. If you haven't used kilobots yet, you should probably start by reading the getting-started guide .","title":"Organisation ( modified by Arthur)"},{"location":"index.html#resources-and-troubleshooting","text":"There are a few important resources available online about kilobots. This guide has been designed has a minimalist introduction to kilobots and swarm robotics. Therefore, if you want to dive deeper in the kilobot universe or have experienced a problem during your learning process, you should check the following websites : The kilobotics website The kilobot library The kilolib source code A \"getting started\" wiki for kilobots Kilobot's user manual The Harvard's Self-Organizing Research Group Repository Kilombo github (added by Arthur) Argos3 github ( added by Arthur)","title":"Resources and troubleshooting"},{"location":"index.html#authors-and-contact","text":"This guide has been written by Simon Lejoly and completed by Barbieux Arthur. It is part of a project commanded by the university of Namur . Note This guide is not an official guide from the kilobot team or K-Team. To find appropriate support, please visit the links listed above.","title":"Authors and contact"},{"location":"about.html","text":"About Authors and contact This guide has been written by Simon Lejoly and completed by Barbieux Arthur. It is part of a project commanded by the university of Namur . Licence Some of the content of this guide, including images, may be subject to copyright.","title":"About"},{"location":"about.html#about","text":"","title":"About"},{"location":"about.html#authors-and-contact","text":"This guide has been written by Simon Lejoly and completed by Barbieux Arthur. It is part of a project commanded by the university of Namur .","title":"Authors and contact"},{"location":"about.html#licence","text":"Some of the content of this guide, including images, may be subject to copyright.","title":"Licence"},{"location":"eclipse_winavr_setup.html","text":"Using Eclipse and WinAVR to Program Kilobots Author: Melvin Gauci; melvin.gauci@gmail.com This document describes how to set up the Eclipse IDE and the WinAVR toolchain to program Kilobots on Windows. NOTE: If you're new to the Kilobot platform, you're advised to use the online Kilobot editor , instead of going through the process below. This process is only worth the trouble for people who'll be working with the Kilobot platform extensively and would like to use a more comprehensive IDE. 1. Install WinAVR 1.1. Download and install WinAVR. During installation, accept the option to install Programmer\u2019s Notepad. 1.2. If you\u2019re running certain versions of Windows (certainly 8.1, and apparently Vista) you\u2019ll need to replace a DLL in the WinAVR installation directory (a bug that's described here ). Download and extract this DLL, and copy it to /utils/bin under your WinAVR installation directory. When prompted if you want to replace the current DLL, accept. 2. Build Kilolib 2.1. Download Kilolib and extract the zipped file. You now need to build Kilolib, and it\u2019s easiest to do this using the Programmer\u2019s Notepad IDE. There's no need to create a project; you just need to point the IDE to the Kilolib directory, and it will execute the Makefile that's in there. 2.2. In Programmer\u2019s Notepad, click File -> Open , navigate to the Kilolib directory and open the file blank.c . 2.3. Click Tools > Make All . If all goes well, you should get: Process Exit Code: 0 . The built files are now found under /build in your Kilolib directory. The static library is the file kilolib.a . 3. Install Eclipse and Plugins First, you need to have Eclipse installed with C/C++ support (the CDT plugin). 3.1. If you don\u2019t plan to use Eclipse for Java development, you can directly download and install the Eclipse IDE for C/C++ Developers version. In this case, skip the next step. 3.2. Alternatively, if you already have Eclipse installed, but not the CDT plugin, install it by following the instructions here . Next, you need to install the AVR Eclipse plugin. Note that this does NOT include an AVR toolchain (compiler, linker, etc.), which is why you installed WinAVR. 3.3. Install the AVR Eclipse plugin by following the instructions here . 4. Set Up an Eclipse Project Now for the slightly grueling part. You'll set up an Eclipse project from scratch with the correct settings to build Kilobot programs. Once you\u2019ve finished, you should probably (read: certainly) make a copy of this \u2018clean\u2019 project as a boilerplate, so you don\u2019t have to repeat this procedure every time you start a new project. Create the Project 4.1. Open Eclipse and select a workspace (e.g. create a directory on your desktop for handiness). 4.2. Click File > New > C Project . In the dialog, give your project a name (here we'll assume it's Kilobot ) and under Project Type , select AVR Cross Target Application > Empty Project . Click Next . 4.3. You probably don\u2019t need both Debug and Release configurations. Uncheck Debug and click Next . 4.4. In the next dialog ( AVR Target Hardware Properties ), under MCU Type select ATmega328P , and set the MCU Frequency to 8000000 Hz (8 MHz). Click Finish . 4.5. Create a new source file in your project by right clicking on the project's name > New > Source File . Give this new source file a name, e.g. main.c . Copy and paste into this file the code from blank.c found in the Kilolib directory. You\u2019ll use this code to make sure everything is working (later, you\u2019ll write your own programs in this file). Set the Header and Library File Paths You now need to provide Eclipse with paths to the Kilolib header (.h) and library (.a) files. Although you could set these paths to any directory on your machine, I recommend copying them into your Eclipse project directory. They're small enough, and this way your project is self-contained. 4.6. In your Eclipse project, create two new directories and call them include and lib (to create a new directory, right click on the project name > New > Folder ). 4.7. Copy all the .h files from the Kilolib directory into the include directory in your project. 4.8. Copy the kilolib.a file from /build in the Kilolib directory into the new lib directory in your project. 4.9. Very importantly , rename the kilolib.a file you just copied into the lib directory to libkilolib.a (i.e. prepend it with \"lib\"). This is because the linker expects all library files to start with \"lib\". You\u2019ll now tell Eclipse where to look for the header and library files you just copied. 4.10. Right click on the project name and click Properties . Go to C/C++ Build -> Settings . Under Tool Settings go to AVR Compiler -> Directories . Under Include Paths (-I) add a new path. Click Workspace and navigate to the include directory in your project. Click OK . 4.11. Still under C/C++ Build -> Settings , go to AVR C Linker -> Libraries . Under Libraries Path (-L) add a new path. Click Workspace and navigate to the lib directory in your project. Click OK . 4.12. Under Libraries (-l) add a library and type: kilolib . The linker will automatically look for a file called libkilolib.a , which is why we renamed this file. Fix a Silly Bug One last step. If you try building now and your coded uses any functions from the math library (math.h), you\u2019ll get an error. This is due to a bug - apparently Eclipse attempts to use the C++ library instead of the C one, and this causes a problem. 4.13. Go to AVR C Linker (this is one level above where you already are). Modify the Command Line Pattern to: ${COMMAND} -lc -lm ${FLAGS} ${OUTPUT_FLAG}${OUTPUT_PREFIX}${OUTPUT} ${INPUTS} -lc . 5. Build Your Code and Upload it to a Kilobot 5.1. Close the settings - you\u2019re now good to go. Build the project by pressing Ctrl+B (or going to Project -> Build All ). A Release directory will be created in your project, and this will contain the object code file (aka \"hex file\"), Kilobot.hex . 5.2. You can now upload the hex file onto your Kilobot robot using the KiloGUI tool . 6. Closing Notes When starting a new project, you might want to rename a copy of your boilerplate project. Apart from renaming the directory, you also need to open each of the files .cproject and .project , and do a Search and Replace operation from the old (boilerplate) project name to your desired new one. Happy coding.","title":"Eclipse winavr setup"},{"location":"eclipse_winavr_setup.html#using-eclipse-and-winavr-to-program-kilobots","text":"Author: Melvin Gauci; melvin.gauci@gmail.com This document describes how to set up the Eclipse IDE and the WinAVR toolchain to program Kilobots on Windows. NOTE: If you're new to the Kilobot platform, you're advised to use the online Kilobot editor , instead of going through the process below. This process is only worth the trouble for people who'll be working with the Kilobot platform extensively and would like to use a more comprehensive IDE.","title":"Using Eclipse and WinAVR to Program Kilobots"},{"location":"eclipse_winavr_setup.html#1-install-winavr","text":"1.1. Download and install WinAVR. During installation, accept the option to install Programmer\u2019s Notepad. 1.2. If you\u2019re running certain versions of Windows (certainly 8.1, and apparently Vista) you\u2019ll need to replace a DLL in the WinAVR installation directory (a bug that's described here ). Download and extract this DLL, and copy it to /utils/bin under your WinAVR installation directory. When prompted if you want to replace the current DLL, accept.","title":"1. Install WinAVR"},{"location":"eclipse_winavr_setup.html#2-build-kilolib","text":"2.1. Download Kilolib and extract the zipped file. You now need to build Kilolib, and it\u2019s easiest to do this using the Programmer\u2019s Notepad IDE. There's no need to create a project; you just need to point the IDE to the Kilolib directory, and it will execute the Makefile that's in there. 2.2. In Programmer\u2019s Notepad, click File -> Open , navigate to the Kilolib directory and open the file blank.c . 2.3. Click Tools > Make All . If all goes well, you should get: Process Exit Code: 0 . The built files are now found under /build in your Kilolib directory. The static library is the file kilolib.a .","title":"2. Build Kilolib"},{"location":"eclipse_winavr_setup.html#3-install-eclipse-and-plugins","text":"First, you need to have Eclipse installed with C/C++ support (the CDT plugin). 3.1. If you don\u2019t plan to use Eclipse for Java development, you can directly download and install the Eclipse IDE for C/C++ Developers version. In this case, skip the next step. 3.2. Alternatively, if you already have Eclipse installed, but not the CDT plugin, install it by following the instructions here . Next, you need to install the AVR Eclipse plugin. Note that this does NOT include an AVR toolchain (compiler, linker, etc.), which is why you installed WinAVR. 3.3. Install the AVR Eclipse plugin by following the instructions here .","title":"3. Install Eclipse and Plugins"},{"location":"eclipse_winavr_setup.html#4-set-up-an-eclipse-project","text":"Now for the slightly grueling part. You'll set up an Eclipse project from scratch with the correct settings to build Kilobot programs. Once you\u2019ve finished, you should probably (read: certainly) make a copy of this \u2018clean\u2019 project as a boilerplate, so you don\u2019t have to repeat this procedure every time you start a new project.","title":"4. Set Up an Eclipse Project"},{"location":"eclipse_winavr_setup.html#create-the-project","text":"4.1. Open Eclipse and select a workspace (e.g. create a directory on your desktop for handiness). 4.2. Click File > New > C Project . In the dialog, give your project a name (here we'll assume it's Kilobot ) and under Project Type , select AVR Cross Target Application > Empty Project . Click Next . 4.3. You probably don\u2019t need both Debug and Release configurations. Uncheck Debug and click Next . 4.4. In the next dialog ( AVR Target Hardware Properties ), under MCU Type select ATmega328P , and set the MCU Frequency to 8000000 Hz (8 MHz). Click Finish . 4.5. Create a new source file in your project by right clicking on the project's name > New > Source File . Give this new source file a name, e.g. main.c . Copy and paste into this file the code from blank.c found in the Kilolib directory. You\u2019ll use this code to make sure everything is working (later, you\u2019ll write your own programs in this file).","title":"Create the Project"},{"location":"eclipse_winavr_setup.html#set-the-header-and-library-file-paths","text":"You now need to provide Eclipse with paths to the Kilolib header (.h) and library (.a) files. Although you could set these paths to any directory on your machine, I recommend copying them into your Eclipse project directory. They're small enough, and this way your project is self-contained. 4.6. In your Eclipse project, create two new directories and call them include and lib (to create a new directory, right click on the project name > New > Folder ). 4.7. Copy all the .h files from the Kilolib directory into the include directory in your project. 4.8. Copy the kilolib.a file from /build in the Kilolib directory into the new lib directory in your project. 4.9. Very importantly , rename the kilolib.a file you just copied into the lib directory to libkilolib.a (i.e. prepend it with \"lib\"). This is because the linker expects all library files to start with \"lib\". You\u2019ll now tell Eclipse where to look for the header and library files you just copied. 4.10. Right click on the project name and click Properties . Go to C/C++ Build -> Settings . Under Tool Settings go to AVR Compiler -> Directories . Under Include Paths (-I) add a new path. Click Workspace and navigate to the include directory in your project. Click OK . 4.11. Still under C/C++ Build -> Settings , go to AVR C Linker -> Libraries . Under Libraries Path (-L) add a new path. Click Workspace and navigate to the lib directory in your project. Click OK . 4.12. Under Libraries (-l) add a library and type: kilolib . The linker will automatically look for a file called libkilolib.a , which is why we renamed this file.","title":"Set the Header and Library File Paths"},{"location":"eclipse_winavr_setup.html#fix-a-silly-bug","text":"One last step. If you try building now and your coded uses any functions from the math library (math.h), you\u2019ll get an error. This is due to a bug - apparently Eclipse attempts to use the C++ library instead of the C one, and this causes a problem. 4.13. Go to AVR C Linker (this is one level above where you already are). Modify the Command Line Pattern to: ${COMMAND} -lc -lm ${FLAGS} ${OUTPUT_FLAG}${OUTPUT_PREFIX}${OUTPUT} ${INPUTS} -lc .","title":"Fix a Silly Bug"},{"location":"eclipse_winavr_setup.html#5-build-your-code-and-upload-it-to-a-kilobot","text":"5.1. Close the settings - you\u2019re now good to go. Build the project by pressing Ctrl+B (or going to Project -> Build All ). A Release directory will be created in your project, and this will contain the object code file (aka \"hex file\"), Kilobot.hex . 5.2. You can now upload the hex file onto your Kilobot robot using the KiloGUI tool .","title":"5. Build Your Code and Upload it to a Kilobot"},{"location":"eclipse_winavr_setup.html#6-closing-notes","text":"When starting a new project, you might want to rename a copy of your boilerplate project. Apart from renaming the directory, you also need to open each of the files .cproject and .project , and do a Search and Replace operation from the old (boilerplate) project name to your desired new one. Happy coding.","title":"6. Closing Notes"},{"location":"to-be-implemented.html","text":"This part of the guide hasn't been implemented yet It will surely be added in a future update... Get back to the home page","title":"This part of the guide hasn't been implemented yet"},{"location":"to-be-implemented.html#this-part-of-the-guide-hasnt-been-implemented-yet","text":"","title":"This part of the guide hasn't been implemented yet"},{"location":"to-be-implemented.html#it-will-surely-be-added-in-a-future-update","text":"Get back to the home page","title":"It will surely be added in a future update..."},{"location":"emulator/argos3/argos3-1.html","text":"Game of life source code of this tutorial Context The Game of Life is a cellular automaton devised by John Horton Conway. It is a simple game where we can choose the initial state of each \"cell\" in the grid board ( living or dead) and see how they evolve. The rules are simple, if a living cell is too isolated it will die the following turn. If it is surrounded by 2 or 3 neighbors it remains alive, but if it is surrounded by more it will die on the following turn. A cell can become a living one if it is surrounded by three other living cells Goal The goal of this project was to recreate the Game of Life with the kilobots but without the grid limitation. Working The kilobots are placed in a large area. They begin in the state \"dead\" or \"living\". The majority of the time they send a message with their status. Next, after a certain few seconds they update their status following the rules of the Game of life. What you will learn Using a linked list with the kilobots Life's program Defining macros, global variables and linked list #define DEAD 0 #define LIVING 1 #define READY 1 #define NOTREADY 0 The 5 globals variables are used to contain: The state of the kilobot. The number of life kilobot neighboring. The number of dead kilobot neighboring. The unique id of the kilobot. The message. int state; int neighbor_living; int neighbor_dead; int id; message_t message; You will see later that the program needs to stock diverse data for each neighboring kilobot . But it is not an easy task since the number of neighbors is changeable and the number of elements in a list must be defined at the initialization in C. This is why I used a linked list to bypass the size limitation of a list. Below is the linked list implementation : struct node { int key; struct node *next; }; struct node *head = NULL; struct node *current = NULL; // to find the length of the list int length() { int length =0; struct node *current; for ( current = head; current != NULL; current = current->next){ length++; } return length; } //is list empty bool isEmpty() { return head == NULL; } //find a link with given key struct node* find(int key) { //start from the first link struct node* current = head; //if list is empty if(head == NULL) { return NULL; } //navigate through list while(current->key != key) { //if it is last node if(current->next == NULL) { return NULL; } else { //go to next link current = current->next; } } //if data found, return the current Link return current; } //delete first item struct node* deleteFirst() { //save reference to first link struct node *tempLink = head; //mark next to first link as first head = head->next; //return the deleted link return tempLink; } //delete a link with given key struct node* delete(int key) { //start from the first link struct node* current = head; struct node* previous = NULL; //if list is empty if(head == NULL) { return NULL; } //navigate through list while(current->key != key) { //if it is last node if(current->next == NULL) { return NULL; } else { //store reference to current link previous = current; //move to next link current = current->next; } } //found a match, update the link if(current == head) { //change first to point to next link head = head->next; } else { //bypass the current link previous->next = current->next; } return current; } //insert link at the first location void insertFirst(int key) { //create a link struct node *link = (struct node*) malloc(sizeof(struct node)); link->key = key; //point it to old first node link->next = head; //point first to new first node head = link; } Some implemented functions are not use by the program but they are still in there for future addons. If you don't understand how a linked list works go to doc here is a website with more explanation. The setup() function In the setup() function all the global variables as well as the structure of the message sent and the color of the kilobot are defined in the setup function. void setup() { //set state state = LIVING; neighbor_dead = 0; neighbor_living = 0; id = kilo_uid; //set the message to send message.type = NORMAL; message.data[0] = state; message.data[1] = id; message.crc = message_crc(&message); //set the light set_color (RGB(0,3,0)); //green } The `loop() function Since `kilo_tocks is incremented 32 times per second, with modulo 64,every 2 seconds the program in the loop is triggered. Every 2 seconds, the rule of the game of life will be applied on the kilobot. void loop() { // All 2 seconds if ((kilo_ticks %64) == 0){ //check if I could be reanimated if(state == DEAD) { if(neighbor_living == 3) { state = LIVING; set_color (RGB(0,3,0)); //green } } //check if if the cellule must die else { if((neighbor_living != 2) && (neighbor_living != 3)) { state = DEAD; set_color (RGB(3,0,0)); //red } } //clear counter and array neighbor_living = 0; neighbor_dead = 0; while(!isEmpty()) { deleteFirst(); } } } You may have already noticed but neighbor_dead is useless. It was kept in the program to help with hypothetical future addons but you can remove it if you don't use it. Communication The message_tx() is relatively classic : message_t* message_tx(){ message.type = NORMAL; message.data[0] = state; message.data[1] = id; message.crc = message_crc(&message); return &message; The message_rx() function is a bit more unusual. It simply checks if the Id isn't already in the linked list and if not it adds it in the list and increments the neighbor_dead or neighbor_living counter. void message_rx(message_t *msg, distance_measurement_t *dist) { struct node *element = find(msg->data[1]); //check if the id wasn't already in the list if(!element){ insertFirst(msg->data[1]); // add a dead cellule in the counter if(msg->data[0] == DEAD) { neighbor_dead += 1; } //add a living cellule in the counter else if(msg->data[0] == LIVING) { neighbor_living += 1; } } } Put it all together ```c int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; } ## Dead's program The two programs are very similar, the only difference is in the \u00b4setup()\u00b4 function. ```c void setup() { //set state state = DEAD; neighbor_dead = 0; neighbor_living = 0; id = kilo_uid; //set the message to send message.type = NORMAL; message.data[0] = state; message.data[1] = id; message.crc = message_crc(&message); //set the light set_color (RGB(3,0,0)); //red } We are done ! You can now play the game of with life your kilobot ! You can now modify their positions to find all the secrets of this game! Just pay attention to the distance between the kilobots. It would be embarrassing that the distance between two of them would be too large to maintain the communication.","title":"Game of life"},{"location":"emulator/argos3/argos3-1.html#game-of-life","text":"source code of this tutorial","title":"Game of life"},{"location":"emulator/argos3/argos3-1.html#context","text":"The Game of Life is a cellular automaton devised by John Horton Conway. It is a simple game where we can choose the initial state of each \"cell\" in the grid board ( living or dead) and see how they evolve. The rules are simple, if a living cell is too isolated it will die the following turn. If it is surrounded by 2 or 3 neighbors it remains alive, but if it is surrounded by more it will die on the following turn. A cell can become a living one if it is surrounded by three other living cells","title":"Context"},{"location":"emulator/argos3/argos3-1.html#goal","text":"The goal of this project was to recreate the Game of Life with the kilobots but without the grid limitation.","title":"Goal"},{"location":"emulator/argos3/argos3-1.html#working","text":"The kilobots are placed in a large area. They begin in the state \"dead\" or \"living\". The majority of the time they send a message with their status. Next, after a certain few seconds they update their status following the rules of the Game of life.","title":"Working"},{"location":"emulator/argos3/argos3-1.html#what-you-will-learn","text":"Using a linked list with the kilobots","title":"What you will learn"},{"location":"emulator/argos3/argos3-1.html#lifes-program","text":"","title":"Life's  program"},{"location":"emulator/argos3/argos3-1.html#defining-macros-global-variables-and-linked-list","text":"#define DEAD 0 #define LIVING 1 #define READY 1 #define NOTREADY 0 The 5 globals variables are used to contain: The state of the kilobot. The number of life kilobot neighboring. The number of dead kilobot neighboring. The unique id of the kilobot. The message. int state; int neighbor_living; int neighbor_dead; int id; message_t message; You will see later that the program needs to stock diverse data for each neighboring kilobot . But it is not an easy task since the number of neighbors is changeable and the number of elements in a list must be defined at the initialization in C. This is why I used a linked list to bypass the size limitation of a list. Below is the linked list implementation : struct node { int key; struct node *next; }; struct node *head = NULL; struct node *current = NULL; // to find the length of the list int length() { int length =0; struct node *current; for ( current = head; current != NULL; current = current->next){ length++; } return length; } //is list empty bool isEmpty() { return head == NULL; } //find a link with given key struct node* find(int key) { //start from the first link struct node* current = head; //if list is empty if(head == NULL) { return NULL; } //navigate through list while(current->key != key) { //if it is last node if(current->next == NULL) { return NULL; } else { //go to next link current = current->next; } } //if data found, return the current Link return current; } //delete first item struct node* deleteFirst() { //save reference to first link struct node *tempLink = head; //mark next to first link as first head = head->next; //return the deleted link return tempLink; } //delete a link with given key struct node* delete(int key) { //start from the first link struct node* current = head; struct node* previous = NULL; //if list is empty if(head == NULL) { return NULL; } //navigate through list while(current->key != key) { //if it is last node if(current->next == NULL) { return NULL; } else { //store reference to current link previous = current; //move to next link current = current->next; } } //found a match, update the link if(current == head) { //change first to point to next link head = head->next; } else { //bypass the current link previous->next = current->next; } return current; } //insert link at the first location void insertFirst(int key) { //create a link struct node *link = (struct node*) malloc(sizeof(struct node)); link->key = key; //point it to old first node link->next = head; //point first to new first node head = link; } Some implemented functions are not use by the program but they are still in there for future addons. If you don't understand how a linked list works go to doc here is a website with more explanation.","title":"Defining macros, global variables and linked list"},{"location":"emulator/argos3/argos3-1.html#the-setup-function","text":"In the setup() function all the global variables as well as the structure of the message sent and the color of the kilobot are defined in the setup function. void setup() { //set state state = LIVING; neighbor_dead = 0; neighbor_living = 0; id = kilo_uid; //set the message to send message.type = NORMAL; message.data[0] = state; message.data[1] = id; message.crc = message_crc(&message); //set the light set_color (RGB(0,3,0)); //green }","title":"The setup() function"},{"location":"emulator/argos3/argos3-1.html#the-loop-function","text":"Since `kilo_tocks is incremented 32 times per second, with modulo 64,every 2 seconds the program in the loop is triggered. Every 2 seconds, the rule of the game of life will be applied on the kilobot. void loop() { // All 2 seconds if ((kilo_ticks %64) == 0){ //check if I could be reanimated if(state == DEAD) { if(neighbor_living == 3) { state = LIVING; set_color (RGB(0,3,0)); //green } } //check if if the cellule must die else { if((neighbor_living != 2) && (neighbor_living != 3)) { state = DEAD; set_color (RGB(3,0,0)); //red } } //clear counter and array neighbor_living = 0; neighbor_dead = 0; while(!isEmpty()) { deleteFirst(); } } } You may have already noticed but neighbor_dead is useless. It was kept in the program to help with hypothetical future addons but you can remove it if you don't use it.","title":"The `loop() function"},{"location":"emulator/argos3/argos3-1.html#communication","text":"The message_tx() is relatively classic : message_t* message_tx(){ message.type = NORMAL; message.data[0] = state; message.data[1] = id; message.crc = message_crc(&message); return &message; The message_rx() function is a bit more unusual. It simply checks if the Id isn't already in the linked list and if not it adds it in the list and increments the neighbor_dead or neighbor_living counter. void message_rx(message_t *msg, distance_measurement_t *dist) { struct node *element = find(msg->data[1]); //check if the id wasn't already in the list if(!element){ insertFirst(msg->data[1]); // add a dead cellule in the counter if(msg->data[0] == DEAD) { neighbor_dead += 1; } //add a living cellule in the counter else if(msg->data[0] == LIVING) { neighbor_living += 1; } } }","title":"Communication"},{"location":"emulator/argos3/argos3-1.html#put-it-all-together","text":"```c int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; } ## Dead's program The two programs are very similar, the only difference is in the \u00b4setup()\u00b4 function. ```c void setup() { //set state state = DEAD; neighbor_dead = 0; neighbor_living = 0; id = kilo_uid; //set the message to send message.type = NORMAL; message.data[0] = state; message.data[1] = id; message.crc = message_crc(&message); //set the light set_color (RGB(3,0,0)); //red }","title":"Put it all together"},{"location":"emulator/argos3/argos3-1.html#we-are-done","text":"You can now play the game of with life your kilobot ! You can now modify their positions to find all the secrets of this game! Just pay attention to the distance between the kilobots. It would be embarrassing that the distance between two of them would be too large to maintain the communication.","title":"We are done !"},{"location":"emulator/argos3/argos3-2.html","text":"Space Attack source code of this tutorial Context This project is based on a variant of the game \"Space Invader\". The goal of the original game was to explode all the aliens with your ship with its laser gun. But in this version, the goal was to shoot the meteore before they blow up the base. Goal The goal of this project was to simulate a video Game with the kilobots. Working the program place the kilobots in a grid (for example a square of 6x6 kilobots). It launch the game which makes the ship appear on the far left on the first row of kilobots (symbolized by a blue color swap of the kilobot). Then the ship moves to right or to left while destroying the asteroids that will appear by firing his lazer at each movement. The game ends if the ship is destroyed or if an asteroid reaches the last row of kilobots. What you will learn Why do you have to pay attention to the color when you use it in the Argos3 emulator. Use more than two different programs simultaneously. Defining macros and global variables //state value #define VIDE 0 // set_color (RGB(0,0,0)); #define METEORE 1 // set_color (RGB(2,1,0)); #define LASER 2 // set_color (RGB(3,3,0)); #define SHIP 3 // set_color (RGB(0,0,3)); #define EXPLOSION 4 // set_color (RGB(3,0,0)); #define GAME_OVER 5 // set_color (RGB(3,3,3)); //type value #define GENERATOR 0 #define PAIR 1 #define ODD 2 #define BASE 3 #define BASE_CENTER 4 #define FALSE 0 #define TRUE 1 //ship movement #define STOP 0 #define RIGHT 1 #define LEFT 2 The globals variables are used to contain : The unique id of the kilobot. The state in the game of the kilobot . The state in the game sends the kilobot. Program's type. The list of unique id of the neighbor(the size can change depending on the program). The Vertical distance. True or False. To know if distance_ship is already set up. The Horizontale distance. True or False. To know if distance_left_ref is already set up. The direction of the ship. The message. The distance between two kilobot. int id; int state; int state_send; int type; int randomizer; int neighbor_array [3]; int distance_ship; int distance_block; int distance_left_ref; int distance_left_ref_block; int ship_movement; int limit; message_t message; distance_measurement_t dist; Meteor program The setup() function //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = GENERATOR; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); The loop() function If the kilobot receives a message with GAME_OVER in it, the game is over and the kilobot sends all his neighbors that the game is over. But else, every 2 seconds, the kilobot will check his state. void loop() { if ( state == GAME_OVER){ set_color (RGB(3,3,3)); state_send = GAME_OVER; } else if((kilo_ticks %64) == 0){ // start loop every 2 sec If his state is VIDE or LASER, there is a one in five chance that a meteor is generated. if ( state == VIDE || state == LASER) { randomizer = rand_hard() %5; // 0 or 1 or 2 or 3 or 4 // meteor generated if (randomizer == 0){ //make an explosion if ( state == LASER){ state = VIDE; set_color (RGB(3,0,0)); state_send = EXPLOSION; } //generate the meteor but don't send the information to wait on turn else{ state = METEORE; set_color (RGB(2,1,0)); state_send = VIDE; } } If the METEORE is not generated, the state become VIDE else { // the laser is clear of the game if (state == LASER){ set_color (RGB(3,3,0)); } // state VIDE else { set_color (RGB(0,0,0)); } state = VIDE; state_send = VIDE; } Otherwise the state was METEORE, the state becomes empty and the program sends the message METEORE to the neighbor because of the wait. else if ( state == METEORE){ state = VIDE; state_send = METEORE; set_color (RGB(2,1,0)); } Otherwise the state was EXPLOSION, the state becomes VIDE and the program sends EXPLOSION. However, the color stays brown to avoid a visual bug. //clear the state of explosion else if ( state == EXPLOSION){ state = VIDE; set_color (RGB(3,0,0)); state_send = EXPLOSION ; } } } And finally, the program clear the list of neighbor //clear neighbor_array memset(neighbor_array,0,1 * sizeof(int)); Communication \u00b4message_tx()\u00b4 is basic but \u00b4message_rx()\u00b4 has a lot to check . //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.crc = message_crc(&message); return &message; } Firstly, the program checks if the message received is GAME_OVER. If yes, it is the end of the function. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (msg->data[0] == GAME_OVER){ //stop the game if GAME_OVER state = GAME_OVER; } Checks if the message of a neighbor has not already been taken into account. If not, stop the loop. int i; for ( i = 0; i<3; i++) { //avoid that a neighbor could be count more than one time if(msg->data[1] == neighbor_array[i]){ //stop loop if message already receive break; } If neighbor_array is not null, the program checks the kilobot type in the message received. if (!neighbor_array[i] ){ The program checks that the type isn't GENERATOR to avoid horizontal communication. // if the message is send by the kilobot under the GENERATOR if (msg->data[2] != GENERATOR){ neighbor_array[i] = msg->data[1]; If the state send is LASER and adapt the new state in function of the current state if (msg->data[0]== LASER ){ if(state == METEORE){ // explode meteor state = EXPLOSION; } // set state to explosion if state_send is METEORE because the meteor wait 2 turn in the GENERATOR else if(state_send == METEORE) { state = EXPLOSION; } else { state = LASER; } Warning Be aware that if you use the real kilobots, the LED's won't turn brown. Some colors are supported by Argos3 but not by the real kilobot! The ODD and PAIR program The code of ODD.C and PAIR.C is exactly the same except for the setup() function therefore I will explain them together by using Pair.c code. You just have to replace \"ODD\" by \"PAIR\" and vice versa in the code. The setup() function void setup() { //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = PAIR; distance_ship = 0; distance_block = FALSE; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); } The loop() function if state received his GAME_OVER, end the game void loop() { if ( state == GAME_OVER){ //game over set_color (RGB(3,3,3)); state_send = GAME_OVER; } Every 2 seconds, state_send becomes state, state becomes VIDE, the color is changed and the list of neighbors is reset. if((kilo_ticks %64) == 0){ // start loop every 2 sec if ( state == VIDE) { state_send = VIDE; set_color (RGB(0,0,0)); } else if (state == METEORE){ state = VIDE; set_color (RGB(2,1,0)); state_send = METEORE; } else if (state == EXPLOSION){ state = VIDE; set_color (RGB(3,0,0)); state_send = EXPLOSION; } else if (state == LASER){ state = VIDE; set_color (RGB(3,3,0)); state_send = LASER; } memset(neighbor_array,0,4 *sizeof(int)); } } Communication //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.crc = message_crc(&message); return &message; } The same as in METEORE.c // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (msg->data[0] == GAME_OVER){ //stop the game if GAME_OVER state = GAME_OVER; } int i; for ( i = 0; i<4; i++) { assert(i<4); //avoid that a cell could be count more than one time if(msg->data[1] == neighbor_array[i]){ //stop loop if message already receive break; } if (!neighbor_array[i] ){ neighbor_array[i] = msg->data[1]; If the kilobot is not locked and that the message received comes from the good type of kilobot, the program locks the kilobot and it gives him a value corresponding to his horizontal distance in the grid. //setup distance of the BASE if (distance_block == FALSE){ if (msg->data[2] == BASE || msg->data[2] == BASE_CENTER || (msg->data[2] == ODD && msg->data[3] != 0) ){ distance_block = TRUE; distance_ship = msg->data[3] + 1; } } If the message received by the same type has the kilobot. if (msg->data[2] != PAIR){ If the message receives a LASER, the program checks the distance_ship to know if the sender of the message is below the current kilobot (because the lasers move from bottom to top.) Next, it changes to the new state depending on the current state. if (msg->data[0] == SHIP || (msg->data[0] == LASER && distance_ship > msg->data[3])) { if ( state == VIDE || state == EXPLOSION) { if (state_send == METEORE){ state = EXPLOSION; } else{ state = LASER; } } else if (state == METEORE){ state = EXPLOSION; } } Otherwise the message received a METEORE, the program checks that the sender of the message is above the current kilobot (because the meteor moves from top to bottom.) else if (msg->data[0] == METEORE && (distance_ship < msg->data[3] || msg->data[2] == GENERATOR )){ if (state == LASER){ if (state_send == LASER){ } else { state = EXPLOSION; } } else if (state == VIDE || state == EXPLOSION) { if (state_send != LASER){ state = METEORE; } } } BASE program The setup() function void setup() { //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = BASE; distance_ship = 0; distance_left_ref = 0; ship_movement = 5; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; //ligne message.data[4] = distance_left_ref; //colonne message.data[5] = ship_movement; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); } The loop() function Same as METEORE.c void loop() { if ( state == GAME_OVER){ //game over set_color (RGB(3,3,3)); } else { if((kilo_ticks %64) == 0){ // start loop every 2 sec Setup ship_movement at 5 in case the ship would not be here. ship_movement = 5; If the ship is here, randomize his deplacement. if ( state == SHIP) { //choice the movement of the ship randomizer = rand_hard() %3 ; //ship go if (randomizer == 0){ state = SHIP; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = STOP; } //ship go left else if (randomizer == 1){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = LEFT; } //ship go right else if (randomizer == 2){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = RIGHT; } } End the game if a meteor hit the BASE. //set state to GAME_OVER else if (state == METEORE){ state = GAME_OVER; set_color (RGB(2,1,0)); state_send = GAME_OVER; } Define state_send depending on state and next clear neighbor_array. //set state to VIDE else if ( state == VIDE){ state_send = VIDE; set_color (RGB(0,0,0)); } //reset state when explosion else if ( state == EXPLOSION){ state_send = VIDE; set_color (RGB(3,0,0)); } //clear neighbor_array memset(neighbor_array,0,3 * sizeof(int)); ### Communication ```c //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; //ligne message.data[4] = distance_left_ref; //colonne message.data[5] = ship_movement; message.crc = message_crc(&message); return &message; } Checks if the game is over. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (msg->data[0] == GAME_OVER){ //stop the game if GAME_OVER state = GAME_OVER; } For each element in the loop check if it has not already received the message. int i; for ( i = 0; i<3; i++) { assert(i<3); //avoid that a cell could be count more than one time if(msg->data[1] == neighbor_array[i]){ //stop loop if message already receive break; } Find the Horizontal value of the kilobot. if (!neighbor_array[i] ){ neighbor_array[i] = msg->data[1]; //Find the distance from Base_left_ref if (distance_left_ref_block == FALSE){ if (msg->data[2] == BASE_CENTER || (msg->data[4] != 0 && msg->data[2] == BASE)){ distance_left_ref_block = TRUE; distance_left_ref = msg->data[4] + 1; } } If the kilobot receives a Ship, check if it's for him or not. //if the ship go RIGHT check if the BASE is at the left of the ship // or //if the ship go LEFT check if the BASE is at the Left of the ship if (msg->data[0] == SHIP && ((msg->data[4] < distance_left_ref && msg->data[5] == RIGHT) || (msg->data[4] > distance_left_ref && msg->data[5] == LEFT))) { //set state to SHIP state = SHIP; } If a message contains METEORE. If it contains the ship, explode the ship. else if (msg->data[0] == METEORE){ //ship explosion if (state == SHIP){ state = EXPLOSION; } If the ship was here one turn before, the state is VIDE because the ship had fired a laser to explode the meteor before. //if the state_send is ship and the state is VIDE then the meteor explode before the BASE so state is VIDE else if(state == VIDE && state_send == SHIP){ state = VIDE; } Otherwise state becomes METEORE. else { // don't stop the game instantly because the ship could be arrive and make an explosion state = METEORE; } BASE_LEFT_REF program BASE_LEFT_REF.c code has the same logic that BASE.C The setup() function distance_left_ref and distance_ship are set up at 0 because this kilobot is the base to generate all the values of the grid. state and state_send are set up to SHIP because the Ship starts here. void setup() { //set the state state = SHIP; state_send = SHIP; id = kilo_uid; type = BASE_CENTER;; distance_ship = 0; distance_left_ref = 0; ship_movement = 5; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.data[4] = distance_left_ref; message.data[5] = ship_movement; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,3)); } The loop() function Same as BASE.c but the ship can go to the left. void loop() { if (randomizer == 0){ state_send = SHIP; ship_movement = STOP; set_color (RGB(0,0,3)); } //ship go right else if (randomizer == 1){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = RIGHT; } Communication //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; //ligne message.data[4] = distance_left_ref; //colonne message.data[5] = ship_movement; message.crc = message_crc(&message); return &message; } Same as BASE.C except that it can not receive a message from his left and it has not to find his distance_left_ref since it is already define. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //if the ship go LEFT check if the BASE is at the Left of the ship if ((msg->data[4] > distance_left_ref && msg->data[5] == LEFT)) { //set state to SHIP state = SHIP; } } BASE_RIGHT program BASE_RIGHT.c code has the same logic that BASE.C The setup() function void setup() { //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = BASE; distance_ship = 0; distance_left_ref = 0; ship_movement = 5; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.data[4] = distance_left_ref; message.data[5] = ship_movement; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); } The loop() function Same as BASE.c but the ship can go to the right. void loop() { //choice the movement of the ship randomizer = rand_hard() %2; //ship stop if (randomizer == 0){ state = SHIP; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = STOP; } //ship go left else if (randomizer == 1){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = LEFT; } Communication //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.data[4] = distance_left_ref; message.data[5] = ship_movement; message.crc = message_crc(&message); return &message; } Same as BASE.c except that it can not receive a message from his right // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //if the ship go RIGHT checks if the BASE is at the left of the ship if (msg->data[0] == SHIP && (msg->data[4] < distance_left_ref && msg->data[5] == RIGHT)) { //set state to SHIP state = SHIP; } Put it all together Obviously, do not forget to add the main() at the end of the program int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; } We are done ! You can now watch the game play itself! You could try to implement a controller but with Argos3, you can not move the kilobot during the simulation.","title":"Space Attack"},{"location":"emulator/argos3/argos3-2.html#space-attack","text":"source code of this tutorial","title":"Space Attack"},{"location":"emulator/argos3/argos3-2.html#context","text":"This project is based on a variant of the game \"Space Invader\". The goal of the original game was to explode all the aliens with your ship with its laser gun. But in this version, the goal was to shoot the meteore before they blow up the base.","title":"Context"},{"location":"emulator/argos3/argos3-2.html#goal","text":"The goal of this project was to simulate a video Game with the kilobots.","title":"Goal"},{"location":"emulator/argos3/argos3-2.html#working","text":"the program place the kilobots in a grid (for example a square of 6x6 kilobots). It launch the game which makes the ship appear on the far left on the first row of kilobots (symbolized by a blue color swap of the kilobot). Then the ship moves to right or to left while destroying the asteroids that will appear by firing his lazer at each movement. The game ends if the ship is destroyed or if an asteroid reaches the last row of kilobots.","title":"Working"},{"location":"emulator/argos3/argos3-2.html#what-you-will-learn","text":"Why do you have to pay attention to the color when you use it in the Argos3 emulator. Use more than two different programs simultaneously.","title":"What you will learn"},{"location":"emulator/argos3/argos3-2.html#defining-macros-and-global-variables","text":"//state value #define VIDE 0 // set_color (RGB(0,0,0)); #define METEORE 1 // set_color (RGB(2,1,0)); #define LASER 2 // set_color (RGB(3,3,0)); #define SHIP 3 // set_color (RGB(0,0,3)); #define EXPLOSION 4 // set_color (RGB(3,0,0)); #define GAME_OVER 5 // set_color (RGB(3,3,3)); //type value #define GENERATOR 0 #define PAIR 1 #define ODD 2 #define BASE 3 #define BASE_CENTER 4 #define FALSE 0 #define TRUE 1 //ship movement #define STOP 0 #define RIGHT 1 #define LEFT 2 The globals variables are used to contain : The unique id of the kilobot. The state in the game of the kilobot . The state in the game sends the kilobot. Program's type. The list of unique id of the neighbor(the size can change depending on the program). The Vertical distance. True or False. To know if distance_ship is already set up. The Horizontale distance. True or False. To know if distance_left_ref is already set up. The direction of the ship. The message. The distance between two kilobot. int id; int state; int state_send; int type; int randomizer; int neighbor_array [3]; int distance_ship; int distance_block; int distance_left_ref; int distance_left_ref_block; int ship_movement; int limit; message_t message; distance_measurement_t dist;","title":"Defining macros and global variables"},{"location":"emulator/argos3/argos3-2.html#meteor-program","text":"","title":"Meteor program"},{"location":"emulator/argos3/argos3-2.html#the-setup-function","text":"//set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = GENERATOR; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0));","title":"The setup() function"},{"location":"emulator/argos3/argos3-2.html#the-loop-function","text":"If the kilobot receives a message with GAME_OVER in it, the game is over and the kilobot sends all his neighbors that the game is over. But else, every 2 seconds, the kilobot will check his state. void loop() { if ( state == GAME_OVER){ set_color (RGB(3,3,3)); state_send = GAME_OVER; } else if((kilo_ticks %64) == 0){ // start loop every 2 sec If his state is VIDE or LASER, there is a one in five chance that a meteor is generated. if ( state == VIDE || state == LASER) { randomizer = rand_hard() %5; // 0 or 1 or 2 or 3 or 4 // meteor generated if (randomizer == 0){ //make an explosion if ( state == LASER){ state = VIDE; set_color (RGB(3,0,0)); state_send = EXPLOSION; } //generate the meteor but don't send the information to wait on turn else{ state = METEORE; set_color (RGB(2,1,0)); state_send = VIDE; } } If the METEORE is not generated, the state become VIDE else { // the laser is clear of the game if (state == LASER){ set_color (RGB(3,3,0)); } // state VIDE else { set_color (RGB(0,0,0)); } state = VIDE; state_send = VIDE; } Otherwise the state was METEORE, the state becomes empty and the program sends the message METEORE to the neighbor because of the wait. else if ( state == METEORE){ state = VIDE; state_send = METEORE; set_color (RGB(2,1,0)); } Otherwise the state was EXPLOSION, the state becomes VIDE and the program sends EXPLOSION. However, the color stays brown to avoid a visual bug. //clear the state of explosion else if ( state == EXPLOSION){ state = VIDE; set_color (RGB(3,0,0)); state_send = EXPLOSION ; } } } And finally, the program clear the list of neighbor //clear neighbor_array memset(neighbor_array,0,1 * sizeof(int));","title":"The loop() function"},{"location":"emulator/argos3/argos3-2.html#communication","text":"\u00b4message_tx()\u00b4 is basic but \u00b4message_rx()\u00b4 has a lot to check . //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.crc = message_crc(&message); return &message; } Firstly, the program checks if the message received is GAME_OVER. If yes, it is the end of the function. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (msg->data[0] == GAME_OVER){ //stop the game if GAME_OVER state = GAME_OVER; } Checks if the message of a neighbor has not already been taken into account. If not, stop the loop. int i; for ( i = 0; i<3; i++) { //avoid that a neighbor could be count more than one time if(msg->data[1] == neighbor_array[i]){ //stop loop if message already receive break; } If neighbor_array is not null, the program checks the kilobot type in the message received. if (!neighbor_array[i] ){ The program checks that the type isn't GENERATOR to avoid horizontal communication. // if the message is send by the kilobot under the GENERATOR if (msg->data[2] != GENERATOR){ neighbor_array[i] = msg->data[1]; If the state send is LASER and adapt the new state in function of the current state if (msg->data[0]== LASER ){ if(state == METEORE){ // explode meteor state = EXPLOSION; } // set state to explosion if state_send is METEORE because the meteor wait 2 turn in the GENERATOR else if(state_send == METEORE) { state = EXPLOSION; } else { state = LASER; } Warning Be aware that if you use the real kilobots, the LED's won't turn brown. Some colors are supported by Argos3 but not by the real kilobot!","title":"Communication"},{"location":"emulator/argos3/argos3-2.html#the-odd-and-pair-program","text":"The code of ODD.C and PAIR.C is exactly the same except for the setup() function therefore I will explain them together by using Pair.c code. You just have to replace \"ODD\" by \"PAIR\" and vice versa in the code.","title":"The ODD and PAIR program"},{"location":"emulator/argos3/argos3-2.html#the-setup-function_1","text":"void setup() { //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = PAIR; distance_ship = 0; distance_block = FALSE; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); }","title":"The setup() function"},{"location":"emulator/argos3/argos3-2.html#the-loop-function_1","text":"if state received his GAME_OVER, end the game void loop() { if ( state == GAME_OVER){ //game over set_color (RGB(3,3,3)); state_send = GAME_OVER; } Every 2 seconds, state_send becomes state, state becomes VIDE, the color is changed and the list of neighbors is reset. if((kilo_ticks %64) == 0){ // start loop every 2 sec if ( state == VIDE) { state_send = VIDE; set_color (RGB(0,0,0)); } else if (state == METEORE){ state = VIDE; set_color (RGB(2,1,0)); state_send = METEORE; } else if (state == EXPLOSION){ state = VIDE; set_color (RGB(3,0,0)); state_send = EXPLOSION; } else if (state == LASER){ state = VIDE; set_color (RGB(3,3,0)); state_send = LASER; } memset(neighbor_array,0,4 *sizeof(int)); } }","title":"The loop() function"},{"location":"emulator/argos3/argos3-2.html#communication_1","text":"//send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.crc = message_crc(&message); return &message; } The same as in METEORE.c // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (msg->data[0] == GAME_OVER){ //stop the game if GAME_OVER state = GAME_OVER; } int i; for ( i = 0; i<4; i++) { assert(i<4); //avoid that a cell could be count more than one time if(msg->data[1] == neighbor_array[i]){ //stop loop if message already receive break; } if (!neighbor_array[i] ){ neighbor_array[i] = msg->data[1]; If the kilobot is not locked and that the message received comes from the good type of kilobot, the program locks the kilobot and it gives him a value corresponding to his horizontal distance in the grid. //setup distance of the BASE if (distance_block == FALSE){ if (msg->data[2] == BASE || msg->data[2] == BASE_CENTER || (msg->data[2] == ODD && msg->data[3] != 0) ){ distance_block = TRUE; distance_ship = msg->data[3] + 1; } } If the message received by the same type has the kilobot. if (msg->data[2] != PAIR){ If the message receives a LASER, the program checks the distance_ship to know if the sender of the message is below the current kilobot (because the lasers move from bottom to top.) Next, it changes to the new state depending on the current state. if (msg->data[0] == SHIP || (msg->data[0] == LASER && distance_ship > msg->data[3])) { if ( state == VIDE || state == EXPLOSION) { if (state_send == METEORE){ state = EXPLOSION; } else{ state = LASER; } } else if (state == METEORE){ state = EXPLOSION; } } Otherwise the message received a METEORE, the program checks that the sender of the message is above the current kilobot (because the meteor moves from top to bottom.) else if (msg->data[0] == METEORE && (distance_ship < msg->data[3] || msg->data[2] == GENERATOR )){ if (state == LASER){ if (state_send == LASER){ } else { state = EXPLOSION; } } else if (state == VIDE || state == EXPLOSION) { if (state_send != LASER){ state = METEORE; } } }","title":"Communication"},{"location":"emulator/argos3/argos3-2.html#base-program","text":"","title":"BASE program"},{"location":"emulator/argos3/argos3-2.html#the-setup-function_2","text":"void setup() { //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = BASE; distance_ship = 0; distance_left_ref = 0; ship_movement = 5; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; //ligne message.data[4] = distance_left_ref; //colonne message.data[5] = ship_movement; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); }","title":"The setup() function"},{"location":"emulator/argos3/argos3-2.html#the-loop-function_2","text":"Same as METEORE.c void loop() { if ( state == GAME_OVER){ //game over set_color (RGB(3,3,3)); } else { if((kilo_ticks %64) == 0){ // start loop every 2 sec Setup ship_movement at 5 in case the ship would not be here. ship_movement = 5; If the ship is here, randomize his deplacement. if ( state == SHIP) { //choice the movement of the ship randomizer = rand_hard() %3 ; //ship go if (randomizer == 0){ state = SHIP; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = STOP; } //ship go left else if (randomizer == 1){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = LEFT; } //ship go right else if (randomizer == 2){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = RIGHT; } } End the game if a meteor hit the BASE. //set state to GAME_OVER else if (state == METEORE){ state = GAME_OVER; set_color (RGB(2,1,0)); state_send = GAME_OVER; } Define state_send depending on state and next clear neighbor_array. //set state to VIDE else if ( state == VIDE){ state_send = VIDE; set_color (RGB(0,0,0)); } //reset state when explosion else if ( state == EXPLOSION){ state_send = VIDE; set_color (RGB(3,0,0)); } //clear neighbor_array memset(neighbor_array,0,3 * sizeof(int)); ### Communication ```c //send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; //ligne message.data[4] = distance_left_ref; //colonne message.data[5] = ship_movement; message.crc = message_crc(&message); return &message; } Checks if the game is over. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (msg->data[0] == GAME_OVER){ //stop the game if GAME_OVER state = GAME_OVER; } For each element in the loop check if it has not already received the message. int i; for ( i = 0; i<3; i++) { assert(i<3); //avoid that a cell could be count more than one time if(msg->data[1] == neighbor_array[i]){ //stop loop if message already receive break; } Find the Horizontal value of the kilobot. if (!neighbor_array[i] ){ neighbor_array[i] = msg->data[1]; //Find the distance from Base_left_ref if (distance_left_ref_block == FALSE){ if (msg->data[2] == BASE_CENTER || (msg->data[4] != 0 && msg->data[2] == BASE)){ distance_left_ref_block = TRUE; distance_left_ref = msg->data[4] + 1; } } If the kilobot receives a Ship, check if it's for him or not. //if the ship go RIGHT check if the BASE is at the left of the ship // or //if the ship go LEFT check if the BASE is at the Left of the ship if (msg->data[0] == SHIP && ((msg->data[4] < distance_left_ref && msg->data[5] == RIGHT) || (msg->data[4] > distance_left_ref && msg->data[5] == LEFT))) { //set state to SHIP state = SHIP; } If a message contains METEORE. If it contains the ship, explode the ship. else if (msg->data[0] == METEORE){ //ship explosion if (state == SHIP){ state = EXPLOSION; } If the ship was here one turn before, the state is VIDE because the ship had fired a laser to explode the meteor before. //if the state_send is ship and the state is VIDE then the meteor explode before the BASE so state is VIDE else if(state == VIDE && state_send == SHIP){ state = VIDE; } Otherwise state becomes METEORE. else { // don't stop the game instantly because the ship could be arrive and make an explosion state = METEORE; }","title":"The loop() function"},{"location":"emulator/argos3/argos3-2.html#base_left_ref-program","text":"BASE_LEFT_REF.c code has the same logic that BASE.C","title":"BASE_LEFT_REF program"},{"location":"emulator/argos3/argos3-2.html#the-setup-function_3","text":"distance_left_ref and distance_ship are set up at 0 because this kilobot is the base to generate all the values of the grid. state and state_send are set up to SHIP because the Ship starts here. void setup() { //set the state state = SHIP; state_send = SHIP; id = kilo_uid; type = BASE_CENTER;; distance_ship = 0; distance_left_ref = 0; ship_movement = 5; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.data[4] = distance_left_ref; message.data[5] = ship_movement; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,3)); }","title":"The setup() function"},{"location":"emulator/argos3/argos3-2.html#the-loop-function_3","text":"Same as BASE.c but the ship can go to the left. void loop() { if (randomizer == 0){ state_send = SHIP; ship_movement = STOP; set_color (RGB(0,0,3)); } //ship go right else if (randomizer == 1){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = RIGHT; }","title":"The loop() function"},{"location":"emulator/argos3/argos3-2.html#communication_2","text":"//send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; //ligne message.data[4] = distance_left_ref; //colonne message.data[5] = ship_movement; message.crc = message_crc(&message); return &message; } Same as BASE.C except that it can not receive a message from his left and it has not to find his distance_left_ref since it is already define. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //if the ship go LEFT check if the BASE is at the Left of the ship if ((msg->data[4] > distance_left_ref && msg->data[5] == LEFT)) { //set state to SHIP state = SHIP; } }","title":"Communication"},{"location":"emulator/argos3/argos3-2.html#base_right-program","text":"BASE_RIGHT.c code has the same logic that BASE.C","title":"BASE_RIGHT program"},{"location":"emulator/argos3/argos3-2.html#the-setup-function_4","text":"void setup() { //set the state state = VIDE; state_send = VIDE; id = kilo_uid; type = BASE; distance_ship = 0; distance_left_ref = 0; ship_movement = 5; //set the message to send message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.data[4] = distance_left_ref; message.data[5] = ship_movement; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); }","title":"The setup() function"},{"location":"emulator/argos3/argos3-2.html#the-loop-function_4","text":"Same as BASE.c but the ship can go to the right. void loop() { //choice the movement of the ship randomizer = rand_hard() %2; //ship stop if (randomizer == 0){ state = SHIP; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = STOP; } //ship go left else if (randomizer == 1){ state = VIDE; set_color (RGB(0,0,3)); state_send = SHIP; ship_movement = LEFT; }","title":"The loop() function"},{"location":"emulator/argos3/argos3-2.html#communication_3","text":"//send a message message_t* message_tx(){ message.type = NORMAL; message.data[0] = state_send; message.data[1] = id; message.data[2] = type; message.data[3] = distance_ship; message.data[4] = distance_left_ref; message.data[5] = ship_movement; message.crc = message_crc(&message); return &message; } Same as BASE.c except that it can not receive a message from his right // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //if the ship go RIGHT checks if the BASE is at the left of the ship if (msg->data[0] == SHIP && (msg->data[4] < distance_left_ref && msg->data[5] == RIGHT)) { //set state to SHIP state = SHIP; }","title":"Communication"},{"location":"emulator/argos3/argos3-2.html#put-it-all-together","text":"Obviously, do not forget to add the main() at the end of the program int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; }","title":"Put it all together"},{"location":"emulator/argos3/argos3-2.html#we-are-done","text":"You can now watch the game play itself! You could try to implement a controller but with Argos3, you can not move the kilobot during the simulation.","title":"We are done !"},{"location":"emulator/argos3/argos3-3.html","text":"Space Attack source code of this tutorial Context When you approach two opposite polarities of a magnet an attraction between them is created. When you approach the same polarity of a magnet, they push each other away. This is caused by what we can call : \"magnetic force\". Goal The goal of this project was to simulate the magnetic force of the magnets . Working This project is a bit special, i was supposed to work by assigning at each kilobot a polarity : North or South. If a kilobot receives a message from a kilobot, he checks his polority. If it is the same, it approaches. If it is the opposite, he moves away. The concept is simple, but the project was a failure. What you will learn What are the limitations of the kilobot How to use a Switch Defining macros, global variables and Switch This part of the program is the same for both. The program defines NORD and SUD who are the type of the kilobot. The program defines STOP, FORWARD, LEFT and RIGHT which are the directions to take. #include <kilolib.h> #include <stdlib.h> #include <stdio.h> #define SUD 0 #define NORD 1 #define STOP 0 #define FORWARD 1 #define LEFT 2 #define RIGHT 3 The \"dist_1,2,3,4,5\" variables are used to store a fixed distance. power stores the fraction of the maximal power to move. type store the type of the kilobot ( SUD or NORD). state store the state of the kilobot (STOP, FORWARD, LEFT and RIGHT ). minimal_distance stores the minimum distance between two kilobot. old_distance stores the old distance between two loops. current_distance stores the current distance between two kilobot. new_message used to check if the distance must be recalculated. message_t store the message. distance_measurement_t stores the distance between two kilobot. int dist_1 = 1000; int dist_2 = 800; int dist_3 = 500; int dist_4 = 250; int dist_5 = 100; float power; int type; int state; int minimal_distance = 10; int old_distance; int current_distance; int new_message; message_t message; distance_measurement_t dist; set_motion() is a function which uses a Switch to define where the power must be used by the motor. void set_motion(int new_motion){ if (power != 0) { switch(new_motion){ case STOP: set_motors(0,0); break; case FORWARD: spinup_motors(); set_motors(255.0 * power,255.0 *power); break; case RIGHT: spinup_motors(); set_motors(0,255.0 * power); break; case LEFT: spinup_motors(); set_motors(255.0 * power,0); break; } } } We use set_motion in three other fonction to define in which direction the kilobot must turn and how many times it has to do it. But as you can see, there is no back() fonction. The cause is simple, the kilobot can not go back! void right(){ set_motion(RIGHT); delay(500); set_motion(FORWARD); delay(100); set_motion(STOP); } void forward(){ set_motion(FORWARD); delay(100); set_motion(STOP); } void left(){ set_motion(LEFT); delay(500); set_motion(FORWARD); delay(100); set_motion(STOP); } NORD program The setup() fonction void setup() { //set the state state = NORD; //set the message to send message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); //set the light set_color (RGB(3,0,0)); current_distance = 5; new_message = 0; old_distance= 5; power = 0 ; type = 5; } The loop() fonction Since the kilobot can not go back, to simulate the polarity between two or more magnets, we need to turn the kilobot on itself and go forward in the direction wanted. However, the kilobot does not have the capacity to know in which direction is the kilobot with whom it communicates. Therefore, it's impossible to determine in which direction the kilobot is to go! To try to solve this problem, the kilobot will try to find in which direction they need to go by trying. For example, if the kilobot is attracted to his partner, it will go forward. If the distance between the two kilobot is bigger than before, it uses right() . If the distance between the two kilobot is smaller than before, it uses left() . The loop continues until the kilobot reaches the minimum distance. This solution could work in most situations if his attractor was fixed but it's not the case. And since both kilobot try to get closer to each other, most of the time they simply make a \"dance\" until they are out of range for communication. The problem is the same when it's two kilobot trying to repulse each other. void loop() { //check if the current distance must be recalculated if (new_message) { new_message = 0; //current_distance = estimate_distance(&message); } if (type == SUD){ //attract if (current_distance <= minimal_distance) { set_motion(STOP); } //turn right and go to the kilobot else if (current_distance > old_distance) { set_motion(LEFT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } //go to the kilobot else if (current_distance == old_distance){ set_motion(FORWARD); delay(100); set_motion(STOP); } //turn right and go to the kilobot else{ set_motion(RIGHT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } } else if (type == NORD) { //repel //turn right and go away if (current_distance < old_distance) { set_motion(RIGHT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } //go away else if (current_distance == old_distance){ set_motion(FORWARD); delay(100); set_motion(STOP); } //turn left and go away else{ set_motion(LEFT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } } type= 5 ; } Communication //send a message message_t* message_tx(){ return &message; } To simulate the fact that when two magnets get closer the power of attraction or repulsion grows, I decided to use a notion of power. More the two magnet are close, more the power his strong and lesser both magnet are close, more the power is weak. However, it is difficult to see if there is a real impact on the kilobot speed because of how the emulator simule it. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //change the polarity of kilobot new_message = 1; type = msg->data[0]; current_distance = estimate_distance(dist); if(current_distance < dist_1){ power = 1.0/5; } else if (current_distance >= dist_1 && current_distance < dist_2) { power = 2.0/5; } else if (current_distance >= dist_2 && current_distance < dist_3) { power = 3.0/5; } else if (current_distance >= dist_3 && current_distance < dist_4) { power = 4.0/5; } else if (current_distance >= dist_4 && current_distance < dist_5) { power = 1.0; } } SUD program The setup() fonction void setup() { //set the state state = SUD; //set the message to send message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); //set the light if (state == SUD){ set_color (RGB(0,3,0)); } else { set_color(RGB(3,0,0)); } current_distance = 5; new_message = 0; old_distance= 5; power = 0 ; type = 5; } The loop() fonction The action executed are inverce compared with NORD.c void loop() { //check if the current distance must be recalculated if (new_message) { new_message = 0; //current_distance = estimate_distance(&message); } if (type == SUD){ //repel if (state == SUD) { // turn right and go away if (current_distance < old_distance) { left(); } // go away else if (current_distance == old_distance ){ forward(); } //turn left and go away else { right(); } } } else if (type == NORD) { //attract if (current_distance <= minimal_distance) { set_motion(STOP); } //turn right and go to the kilobot else if (current_distance > old_distance) { set_motion(LEFT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } //go to the kilobot else if (current_distance == old_distance){ set_motion(FORWARD); delay(100); set_motion(STOP); } //turn right and go to the kilobot else{ set_motion(RIGHT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } } type= 5 ; } Communication //send a message message_t* message_tx(){ return &message; } // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //change the polarity of kilobot new_message = 1; type = msg->data[0]; current_distance = estimate_distance(dist); if(current_distance < dist_1){ power = 1.0/5; } else if (current_distance >= dist_1 && current_distance < dist_2) { power = 2.0/5; } else if (current_distance >= dist_2 && current_distance < dist_3) { power = 3.0/5; } else if (current_distance >= dist_3 && current_distance < dist_4) { power = 4.0/5; } else if (current_distance >= dist_4 && current_distance < dist_5) { power = 1.0; } } Put it together! There is no difference in the main function for both program int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; } Conclusion! Now that you learn the mistakes made in this project, you should be able to avoid them.Therefore when you will start your own project don\u2019t forget to take into account this limitation.","title":"Magnet"},{"location":"emulator/argos3/argos3-3.html#space-attack","text":"source code of this tutorial","title":"Space Attack"},{"location":"emulator/argos3/argos3-3.html#context","text":"When you approach two opposite polarities of a magnet an attraction between them is created. When you approach the same polarity of a magnet, they push each other away. This is caused by what we can call : \"magnetic force\".","title":"Context"},{"location":"emulator/argos3/argos3-3.html#goal","text":"The goal of this project was to simulate the magnetic force of the magnets .","title":"Goal"},{"location":"emulator/argos3/argos3-3.html#working","text":"This project is a bit special, i was supposed to work by assigning at each kilobot a polarity : North or South. If a kilobot receives a message from a kilobot, he checks his polority. If it is the same, it approaches. If it is the opposite, he moves away. The concept is simple, but the project was a failure.","title":"Working"},{"location":"emulator/argos3/argos3-3.html#what-you-will-learn","text":"What are the limitations of the kilobot How to use a Switch","title":"What you will learn"},{"location":"emulator/argos3/argos3-3.html#defining-macros-global-variables-and-switch","text":"This part of the program is the same for both. The program defines NORD and SUD who are the type of the kilobot. The program defines STOP, FORWARD, LEFT and RIGHT which are the directions to take. #include <kilolib.h> #include <stdlib.h> #include <stdio.h> #define SUD 0 #define NORD 1 #define STOP 0 #define FORWARD 1 #define LEFT 2 #define RIGHT 3 The \"dist_1,2,3,4,5\" variables are used to store a fixed distance. power stores the fraction of the maximal power to move. type store the type of the kilobot ( SUD or NORD). state store the state of the kilobot (STOP, FORWARD, LEFT and RIGHT ). minimal_distance stores the minimum distance between two kilobot. old_distance stores the old distance between two loops. current_distance stores the current distance between two kilobot. new_message used to check if the distance must be recalculated. message_t store the message. distance_measurement_t stores the distance between two kilobot. int dist_1 = 1000; int dist_2 = 800; int dist_3 = 500; int dist_4 = 250; int dist_5 = 100; float power; int type; int state; int minimal_distance = 10; int old_distance; int current_distance; int new_message; message_t message; distance_measurement_t dist; set_motion() is a function which uses a Switch to define where the power must be used by the motor. void set_motion(int new_motion){ if (power != 0) { switch(new_motion){ case STOP: set_motors(0,0); break; case FORWARD: spinup_motors(); set_motors(255.0 * power,255.0 *power); break; case RIGHT: spinup_motors(); set_motors(0,255.0 * power); break; case LEFT: spinup_motors(); set_motors(255.0 * power,0); break; } } } We use set_motion in three other fonction to define in which direction the kilobot must turn and how many times it has to do it. But as you can see, there is no back() fonction. The cause is simple, the kilobot can not go back! void right(){ set_motion(RIGHT); delay(500); set_motion(FORWARD); delay(100); set_motion(STOP); } void forward(){ set_motion(FORWARD); delay(100); set_motion(STOP); } void left(){ set_motion(LEFT); delay(500); set_motion(FORWARD); delay(100); set_motion(STOP); }","title":"Defining macros, global variables and Switch"},{"location":"emulator/argos3/argos3-3.html#nord-program","text":"","title":"NORD program"},{"location":"emulator/argos3/argos3-3.html#the-setup-fonction","text":"void setup() { //set the state state = NORD; //set the message to send message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); //set the light set_color (RGB(3,0,0)); current_distance = 5; new_message = 0; old_distance= 5; power = 0 ; type = 5; }","title":"The setup() fonction"},{"location":"emulator/argos3/argos3-3.html#the-loop-fonction","text":"Since the kilobot can not go back, to simulate the polarity between two or more magnets, we need to turn the kilobot on itself and go forward in the direction wanted. However, the kilobot does not have the capacity to know in which direction is the kilobot with whom it communicates. Therefore, it's impossible to determine in which direction the kilobot is to go! To try to solve this problem, the kilobot will try to find in which direction they need to go by trying. For example, if the kilobot is attracted to his partner, it will go forward. If the distance between the two kilobot is bigger than before, it uses right() . If the distance between the two kilobot is smaller than before, it uses left() . The loop continues until the kilobot reaches the minimum distance. This solution could work in most situations if his attractor was fixed but it's not the case. And since both kilobot try to get closer to each other, most of the time they simply make a \"dance\" until they are out of range for communication. The problem is the same when it's two kilobot trying to repulse each other. void loop() { //check if the current distance must be recalculated if (new_message) { new_message = 0; //current_distance = estimate_distance(&message); } if (type == SUD){ //attract if (current_distance <= minimal_distance) { set_motion(STOP); } //turn right and go to the kilobot else if (current_distance > old_distance) { set_motion(LEFT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } //go to the kilobot else if (current_distance == old_distance){ set_motion(FORWARD); delay(100); set_motion(STOP); } //turn right and go to the kilobot else{ set_motion(RIGHT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } } else if (type == NORD) { //repel //turn right and go away if (current_distance < old_distance) { set_motion(RIGHT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } //go away else if (current_distance == old_distance){ set_motion(FORWARD); delay(100); set_motion(STOP); } //turn left and go away else{ set_motion(LEFT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } } type= 5 ; }","title":"The loop() fonction"},{"location":"emulator/argos3/argos3-3.html#communication","text":"//send a message message_t* message_tx(){ return &message; } To simulate the fact that when two magnets get closer the power of attraction or repulsion grows, I decided to use a notion of power. More the two magnet are close, more the power his strong and lesser both magnet are close, more the power is weak. However, it is difficult to see if there is a real impact on the kilobot speed because of how the emulator simule it. // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //change the polarity of kilobot new_message = 1; type = msg->data[0]; current_distance = estimate_distance(dist); if(current_distance < dist_1){ power = 1.0/5; } else if (current_distance >= dist_1 && current_distance < dist_2) { power = 2.0/5; } else if (current_distance >= dist_2 && current_distance < dist_3) { power = 3.0/5; } else if (current_distance >= dist_3 && current_distance < dist_4) { power = 4.0/5; } else if (current_distance >= dist_4 && current_distance < dist_5) { power = 1.0; } }","title":"Communication"},{"location":"emulator/argos3/argos3-3.html#sud-program","text":"","title":"SUD program"},{"location":"emulator/argos3/argos3-3.html#the-setup-fonction_1","text":"void setup() { //set the state state = SUD; //set the message to send message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); //set the light if (state == SUD){ set_color (RGB(0,3,0)); } else { set_color(RGB(3,0,0)); } current_distance = 5; new_message = 0; old_distance= 5; power = 0 ; type = 5; }","title":"The setup() fonction"},{"location":"emulator/argos3/argos3-3.html#the-loop-fonction_1","text":"The action executed are inverce compared with NORD.c void loop() { //check if the current distance must be recalculated if (new_message) { new_message = 0; //current_distance = estimate_distance(&message); } if (type == SUD){ //repel if (state == SUD) { // turn right and go away if (current_distance < old_distance) { left(); } // go away else if (current_distance == old_distance ){ forward(); } //turn left and go away else { right(); } } } else if (type == NORD) { //attract if (current_distance <= minimal_distance) { set_motion(STOP); } //turn right and go to the kilobot else if (current_distance > old_distance) { set_motion(LEFT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } //go to the kilobot else if (current_distance == old_distance){ set_motion(FORWARD); delay(100); set_motion(STOP); } //turn right and go to the kilobot else{ set_motion(RIGHT); delay(100); set_motion(FORWARD); delay(100); set_motion(STOP); } } type= 5 ; }","title":"The loop() fonction"},{"location":"emulator/argos3/argos3-3.html#communication_1","text":"//send a message message_t* message_tx(){ return &message; } // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { //change the polarity of kilobot new_message = 1; type = msg->data[0]; current_distance = estimate_distance(dist); if(current_distance < dist_1){ power = 1.0/5; } else if (current_distance >= dist_1 && current_distance < dist_2) { power = 2.0/5; } else if (current_distance >= dist_2 && current_distance < dist_3) { power = 3.0/5; } else if (current_distance >= dist_3 && current_distance < dist_4) { power = 4.0/5; } else if (current_distance >= dist_4 && current_distance < dist_5) { power = 1.0; } }","title":"Communication"},{"location":"emulator/argos3/argos3-3.html#put-it-together","text":"There is no difference in the main function for both program int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; }","title":"Put it together!"},{"location":"emulator/argos3/argos3-3.html#conclusion","text":"Now that you learn the mistakes made in this project, you should be able to avoid them.Therefore when you will start your own project don\u2019t forget to take into account this limitation.","title":"Conclusion!"},{"location":"emulator/argos3/argos3-4.html","text":"Space Attack source code of this tutorial Context In retirement homes, the physical activity of the occupants is a priority. Playing to roll the ball in a circle is, for example, a good activity that does not require too much effort from the resident. However, with limited staff and means, this task is sometimes complicated. Goal The goal of this project was to simulate some old people playing at the ball with a hunter trying to catch the ball . Working There is 3 types of kilobots : The kilobot \"ball\" moving in the circle by \"bouncing off\" the \"walls\". The kilobot \"hunter\" moving in the circle around him too by bouncing off the walls. The kilobots \"wall\" that symbolizes the resident. They do nothing except send a message with their type to the kilobot ball and hunter. What you will learn How to solve a problem in real life with the kilobot. WALL program Defining macros and global variables There are 3 macros defined who represents the type of the kilobot and one variable to store the message. #define BALLE 0 #define HUNTER 1 #define LIMIT 2 message_t message; The setup() function The kilobots WALL are only useful to define the play area. So their only goal is to warn the other kilobot that they have arrived at the end of the play area. void setup() { //set the message to send message.type = NORMAL; message.data[0] = LIMIT; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); } The other fonction void loop() { } //send message message_t* message_tx(){ return &message; } //check message void message_rx(message_t *msg, distance_measurement_t *dist) { } int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; } Hunter and Ball program Defining macros and global variables #define BALLE 0 #define HUNTER 1 #define LIMIT 2 #define CATCH 0 #define WALL 1 #define RUN 2 #define READY 0 #define NOTREADY 1 This variables are used to : store the state store if ready or not had the distance when the ball is considered catch had the delay to go straight on 1 cm (irl kilobot) had the delay to make a half turn on himself ( irl kilobot) store the delay to subtract or add store the message int state; int ready; int catch_distance = 100; int straightSpeedCalibrator = 1000; // Delay in milliseconds to go straight on 1cm (for irl kilobot) int turningSpeedCalibrator = 2500; // Delay in milliseconds to make 1/2 turn around (for irl kilobot) int Thedelay; message_t message; The setup() fonction The difference between Hunter and Ball is that \"message.data[0] = Hunter\" is equal at \"BALL\" in Ball. void setup() { //set de random seed rand_seed(1); //set the state state = RUN; ready = READY; //set the message to send message.type = NORMAL; message.data[0] = HUNTER; message.crc = message_crc(&message); //set the light and movement set_color (RGB(3,0,0)); } The loop() fonction In the loop fonction the kilobot will go forward until it encounters an obstacle. If it is the Hunter or the Ball, it is the end of the game. But if it is a wall, the kilobot will make a maneuver to turn on itself randomly and return to the circle. void loop() { if (state == RUN){ // waiting hunter get away if (ready == NOTREADY) { set_motors(kilo_straight_left, kilo_straight_right); delay(straightSpeedCalibrator); ready = READY; } set_color (RGB(3,0,0)); //red //go straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); } //end the simulation, the ball is catch else if (state == CATCH) { ready = NOTREADY; set_color (RGB(0,3,0)); set_motors(0,0); } // use to not apply a new message during the rotation else if (state == WALL){ ready = NOTREADY; //choice a random direction in the circle int rotate = rand_soft() %501 ; //0 to 500 int more_less = rand_soft() %2; //0 or 1 //make an \"+\" if (more_less == 1){ Thedelay = (turningSpeedCalibrator + rotate); } //make a \"-\" else{ Thedelay = (turningSpeedCalibrator - rotate); } //change state to RUN again and turn the hunter more_less = rand_soft() %2; //0 or 1 spinup_motors(); //turn right or left if (more_less == 1){ set_motors(kilo_turn_left, 0); } else{ set_motors(kilo_turn_right, 0); } delay(Thedelay); state = RUN; } } Communication If receive a message from the Ball, end of the game Else if receive a message from a wall, pass the state to the wall to make a maneuver. Same logic for the Hunter except it has to receive a message from the ball. //send a message message_t* message_tx(){ return &message; } // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (estimate_distance(dist) < (catch_distance) ){ if (msg->data[0] == BALLE){ state = CATCH; } else if (state == RUN && ready == READY) { if (msg->data[0] == LIMIT){ state = WALL; } } } } ## Put it together! int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; } We are done ! You can now see the Hunter trying to catch the Ball running away! Of course, they do not use the more efficient way but with the kilobot limited characteristics it would be difficult to be more efficient.","title":"Catch The Ball"},{"location":"emulator/argos3/argos3-4.html#space-attack","text":"source code of this tutorial","title":"Space Attack"},{"location":"emulator/argos3/argos3-4.html#context","text":"In retirement homes, the physical activity of the occupants is a priority. Playing to roll the ball in a circle is, for example, a good activity that does not require too much effort from the resident. However, with limited staff and means, this task is sometimes complicated.","title":"Context"},{"location":"emulator/argos3/argos3-4.html#goal","text":"The goal of this project was to simulate some old people playing at the ball with a hunter trying to catch the ball .","title":"Goal"},{"location":"emulator/argos3/argos3-4.html#working","text":"There is 3 types of kilobots : The kilobot \"ball\" moving in the circle by \"bouncing off\" the \"walls\". The kilobot \"hunter\" moving in the circle around him too by bouncing off the walls. The kilobots \"wall\" that symbolizes the resident. They do nothing except send a message with their type to the kilobot ball and hunter.","title":"Working"},{"location":"emulator/argos3/argos3-4.html#what-you-will-learn","text":"How to solve a problem in real life with the kilobot.","title":"What you will learn"},{"location":"emulator/argos3/argos3-4.html#wall-program","text":"","title":"WALL program"},{"location":"emulator/argos3/argos3-4.html#defining-macros-and-global-variables","text":"There are 3 macros defined who represents the type of the kilobot and one variable to store the message. #define BALLE 0 #define HUNTER 1 #define LIMIT 2 message_t message;","title":"Defining macros and global variables"},{"location":"emulator/argos3/argos3-4.html#the-setup-function","text":"The kilobots WALL are only useful to define the play area. So their only goal is to warn the other kilobot that they have arrived at the end of the play area. void setup() { //set the message to send message.type = NORMAL; message.data[0] = LIMIT; message.crc = message_crc(&message); //set the light set_color (RGB(0,0,0)); }","title":"The setup() function"},{"location":"emulator/argos3/argos3-4.html#the-other-fonction","text":"void loop() { } //send message message_t* message_tx(){ return &message; } //check message void message_rx(message_t *msg, distance_measurement_t *dist) { } int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; }","title":"The other fonction"},{"location":"emulator/argos3/argos3-4.html#hunter-and-ball-program","text":"","title":"Hunter and Ball program"},{"location":"emulator/argos3/argos3-4.html#defining-macros-and-global-variables_1","text":"#define BALLE 0 #define HUNTER 1 #define LIMIT 2 #define CATCH 0 #define WALL 1 #define RUN 2 #define READY 0 #define NOTREADY 1 This variables are used to : store the state store if ready or not had the distance when the ball is considered catch had the delay to go straight on 1 cm (irl kilobot) had the delay to make a half turn on himself ( irl kilobot) store the delay to subtract or add store the message int state; int ready; int catch_distance = 100; int straightSpeedCalibrator = 1000; // Delay in milliseconds to go straight on 1cm (for irl kilobot) int turningSpeedCalibrator = 2500; // Delay in milliseconds to make 1/2 turn around (for irl kilobot) int Thedelay; message_t message;","title":"Defining macros and global variables"},{"location":"emulator/argos3/argos3-4.html#the-setup-fonction","text":"The difference between Hunter and Ball is that \"message.data[0] = Hunter\" is equal at \"BALL\" in Ball. void setup() { //set de random seed rand_seed(1); //set the state state = RUN; ready = READY; //set the message to send message.type = NORMAL; message.data[0] = HUNTER; message.crc = message_crc(&message); //set the light and movement set_color (RGB(3,0,0)); }","title":"The setup() fonction"},{"location":"emulator/argos3/argos3-4.html#the-loop-fonction","text":"In the loop fonction the kilobot will go forward until it encounters an obstacle. If it is the Hunter or the Ball, it is the end of the game. But if it is a wall, the kilobot will make a maneuver to turn on itself randomly and return to the circle. void loop() { if (state == RUN){ // waiting hunter get away if (ready == NOTREADY) { set_motors(kilo_straight_left, kilo_straight_right); delay(straightSpeedCalibrator); ready = READY; } set_color (RGB(3,0,0)); //red //go straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); } //end the simulation, the ball is catch else if (state == CATCH) { ready = NOTREADY; set_color (RGB(0,3,0)); set_motors(0,0); } // use to not apply a new message during the rotation else if (state == WALL){ ready = NOTREADY; //choice a random direction in the circle int rotate = rand_soft() %501 ; //0 to 500 int more_less = rand_soft() %2; //0 or 1 //make an \"+\" if (more_less == 1){ Thedelay = (turningSpeedCalibrator + rotate); } //make a \"-\" else{ Thedelay = (turningSpeedCalibrator - rotate); } //change state to RUN again and turn the hunter more_less = rand_soft() %2; //0 or 1 spinup_motors(); //turn right or left if (more_less == 1){ set_motors(kilo_turn_left, 0); } else{ set_motors(kilo_turn_right, 0); } delay(Thedelay); state = RUN; } }","title":"The loop() fonction"},{"location":"emulator/argos3/argos3-4.html#communication","text":"If receive a message from the Ball, end of the game Else if receive a message from a wall, pass the state to the wall to make a maneuver. Same logic for the Hunter except it has to receive a message from the ball. //send a message message_t* message_tx(){ return &message; } // check a message void message_rx(message_t *msg, distance_measurement_t *dist) { if (estimate_distance(dist) < (catch_distance) ){ if (msg->data[0] == BALLE){ state = CATCH; } else if (state == RUN && ready == READY) { if (msg->data[0] == LIMIT){ state = WALL; } } } } ## Put it together! int main(){ kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; kilo_start(setup, loop); return 0; }","title":"Communication"},{"location":"emulator/argos3/argos3-4.html#we-are-done","text":"You can now see the Hunter trying to catch the Ball running away! Of course, they do not use the more efficient way but with the kilobot limited characteristics it would be difficult to be more efficient.","title":"We are done !"},{"location":"emulator/argos3/argos3-index.html","text":"Argos3 This guide currently presents 4 easy and diverse tutorials. Warning This guide assumes that you already see the tutorials part! Game of life Number of kilobots : arbitrary Topic : Recreate the game of life Learn how you can recreate the game of life by using kilobots. Space Attack Number of kilobots : minimum 3 Topic : recreate a simple video game Learn how to make a simple video game by using kilobots. Magnet Number of kilobots : minimum 2 Topic : Kilobot limitation Learn the mistakes that occured in this project and how to avoid them. Catch The Ball Number of kilobots : minimum 2 Topic : helping older people Learn how to solve a problem in real life by simplifying it and using kilobots.","title":"Argos3 summary"},{"location":"emulator/argos3/argos3-index.html#argos3","text":"This guide currently presents 4 easy and diverse tutorials. Warning This guide assumes that you already see the tutorials part!","title":"Argos3"},{"location":"emulator/argos3/argos3-index.html#game-of-life","text":"Number of kilobots : arbitrary Topic : Recreate the game of life Learn how you can recreate the game of life by using kilobots.","title":"Game of life"},{"location":"emulator/argos3/argos3-index.html#space-attack","text":"Number of kilobots : minimum 3 Topic : recreate a simple video game Learn how to make a simple video game by using kilobots.","title":"Space Attack"},{"location":"emulator/argos3/argos3-index.html#magnet","text":"Number of kilobots : minimum 2 Topic : Kilobot limitation Learn the mistakes that occured in this project and how to avoid them.","title":"Magnet"},{"location":"emulator/argos3/argos3-index.html#catch-the-ball","text":"Number of kilobots : minimum 2 Topic : helping older people Learn how to solve a problem in real life by simplifying it and using kilobots.","title":"Catch The Ball"},{"location":"emulator/kilombo/kilombo-index.html","text":"Kilombo This guide currently presents 0 tutorials. This place is reserved for future Kilombo projects. Apologies for the inconvenience. Do not hesitate to complete this section with your projects","title":"Kilombo summary"},{"location":"emulator/kilombo/kilombo-index.html#kilombo","text":"This guide currently presents 0 tutorials. This place is reserved for future Kilombo projects. Apologies for the inconvenience.","title":"Kilombo"},{"location":"emulator/kilombo/kilombo-index.html#do-not-hesitate-to-complete-this-section-with-your-projects","text":"","title":"Do not hesitate to complete this section with your projects"},{"location":"guides/coding-for-kilobots.html","text":"Coding for kilobots Programs for kilobots are coded in C language, then compiled as hex instructions for the kilobot to read. Note If you are not familiar with the C language, your priority should be to learn its basics. Here is a great tutorial to get you started. Default template The default template for the kilobot code looks like this : #include <kilolib.h> void setup() { // Put your setup code here, to be run only once } void loop() { // Put your main code here, to be run repeatedly } int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } This code shows the two main parts of a kilobot program : the setup and loop functions. The setup() function is executed only once, at the very start of the execution. It's a great place to put the code that initializes some variables or constants. The loop() function is run repeatedly during the whole execution. It's where the common behavior of the kilobot is implemented. Basic functions Here are some of the most useful functions of the kilolib library : Function Effects kilo_init() Initializes kilobot's hardware kilo_start(setup, loop) Starts the execution of the program RGB(r, g, b) Converts RGB code to a parameter used by set_color() set_color(color) Sets the kilobot's LED color set_motors(left, right) Sets each motor speed, enabling movement delay(millis) Pauses the execution for a given amount of milliseconds","title":"Coding for kilobots"},{"location":"guides/coding-for-kilobots.html#coding-for-kilobots","text":"Programs for kilobots are coded in C language, then compiled as hex instructions for the kilobot to read. Note If you are not familiar with the C language, your priority should be to learn its basics. Here is a great tutorial to get you started.","title":"Coding for kilobots"},{"location":"guides/coding-for-kilobots.html#default-template","text":"The default template for the kilobot code looks like this : #include <kilolib.h> void setup() { // Put your setup code here, to be run only once } void loop() { // Put your main code here, to be run repeatedly } int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } This code shows the two main parts of a kilobot program : the setup and loop functions. The setup() function is executed only once, at the very start of the execution. It's a great place to put the code that initializes some variables or constants. The loop() function is run repeatedly during the whole execution. It's where the common behavior of the kilobot is implemented.","title":"Default template"},{"location":"guides/coding-for-kilobots.html#basic-functions","text":"Here are some of the most useful functions of the kilolib library : Function Effects kilo_init() Initializes kilobot's hardware kilo_start(setup, loop) Starts the execution of the program RGB(r, g, b) Converts RGB code to a parameter used by set_color() set_color(color) Sets the kilobot's LED color set_motors(left, right) Sets each motor speed, enabling movement delay(millis) Pauses the execution for a given amount of milliseconds","title":"Basic functions"},{"location":"guides/compile-your-code.html","text":"Compile your code There are many ways to compile code for kilobots. This guide presents two of them. Note The following methods have mostly been tested on MacOS Big Sur . If you experience any problem, please consider visiting this quick-start wiki or this guide from the official website (go to 'advanced use' in the 'documentation' section). Both of those websites where used to write this guide. Compiling your code - the easy way The kilobotics website provides a simple online editor to write code for kilobots. Once logged in with your Dropbox account, you can access the editor, create new programs and save them. To compile your program, just click the green compile button. A .hex file with the same name as your .c file should appear in the KiloEdit directory of your dropbox. Warning Kilobotics' online editor has aged and is not really maintained anymore. Depending on your operating system, browser or dropbox account and configurations, the editor may not work properly. If this is your case, please use the alternative method presented below. Compiling your code - the less-easy way If the kilobotics' online editor doesn't work or doesn't suit your needs, you can still go for the tough method : compiling the code manually. The goal of this tutorial is to get you a simple command-line utility to easily compile your different programs. Warning The following method may not work with Windows operating systems. We suggest that Windows users use a virtual machine running Linux. Step 1 : install AVR compilator For Linux using apt Run the following command in the terminal : sudo apt-get install avr-libc gcc-avr avrdude For MacOS using homebrew Run the following command in the terminal : brew tap osx-cross/avr brew install avr-gcc Step 2 : download the template code To get the task simpler, download this file . It contains a shell script that will take care of library dependencies and allow us to compile code with just one command. Step 3 : place your files inside the template directory Place your files inside the 'TemplateForCompiling' directory. They should now be in the same directory as compileCode.sh . Step 4 : compile with one command Open a terminal window and navigate inside the 'TemplateForCompiling' directory with the cd command. Type the following command : ./compileCode.sh your-file Note Replace 'your-file' by the real name of the file you want to compile. Note Note how we didn't put the .c extension at the end of the file name. We are done ! The .hex file corresponding to your program should now appear inside the 'TemplateForCompiling/build/' directory. If anything went wrong, refer to the error message returned by the compileCode.sh script. If your code contains syntaxical errors, they will be listed there. Compiling your code - the windows' hard way If the kilobotics' online editor doesn't work or doesn't suit your needs and that you are a windows\u2019 user who doesn't want to use a virtual machine, this way is for you. The goal of this tutorial is to get you a simplified guide to compile on windows with Eclipse IDE and the WinAVR . Step 1 : Install WinAVR Download and install WinAVR. During installation, accept the option to install Programmer\u2019s Notepad. Step 2 : Build Kilolib Download Kilolib and extract the zipped file. In your text editor of preference, click File -> Open , navigate to the Kilolib directory and open the file blank.c . Click Tools > Make All . Note If all goes well, you should get: Process Exit Code: 0 . The built files are now found under /build in your Kilolib directory. The static library is the file kilolib.a . Step 3 : Install Eclipse and Plugins Install Eclipse with c/c++ support, link available here Install the AVR Eclipse plugin by following the instructions here . Step 4 : Create the Project Open Eclipse and select a workspace. Click File > New > C Project . In the dialog, give your project a name (here we'll assume it's Kilobot ) and under Project Type , select AVR Cross Target Application > Empty Project . Click Next . Uncheck Debug and click Next . In the next dialog ( AVR Target Hardware Properties ), under MCU Type select ATmega328P , and set the MCU Frequency to 8000000 Hz (8 MHz). Click Finish . Create a new source file in your project by right clicking on the project's name > New > Source File . Give this new source file a name, e.g. main.c . Copy and paste into this file the code from blank.c found in the Kilolib directory. Step 5 : Set the Header and Library File Paths In your Eclipse project, create two new directories and call them include and lib (to create a new directory, right click on the project name > New > Folder ). Copy all the .h files from the Kilolib directory into the include directory in your project. Copy the kilolib.a file from /build in the Kilolib directory into the new lib directory in your project. Rename the kilolib.a file you just copied into the lib directory to libkilolib.a (i.e. prepend it with \"lib\"). Right click on the project name and click Properties . Go to C/C++ Build -> Settings . Under Tool Settings go to AVR Compiler -> Directories . Under Include Paths (-I) add a new path. Click Workspace and navigate to the include directory in your project. Click OK . Still under C/C++ Build -> Settings , go to AVR C Linker -> Libraries . Under Libraries Path (-L) add a new path. Click Workspace and navigate to the lib directory in your project. Click OK . Under Libraries (-l) add a library and type: kilolib . Step 6 : Build Your Code and Upload it to a Kilobot Close the settings - you\u2019re now good to go. Build the project by pressing Ctrl+B (or going to Project -> Build All ). A Release directory will be created in your project, and this will contain the object code file (aka \"hex file\"), Kilobot.hex . You can now upload the hex file onto your Kilobot robot using the KiloGUI tool . Note When starting a new project, you might want to rename a copy of your boilerplate project. Apart from renaming the directory, you also need to open each of the files .cproject and .project , and do a Search and Replace operation from the old (boilerplate) project name to your desired new one. If you want the complete guide or if you have some unexpected results you can click here","title":"Compile your code "},{"location":"guides/compile-your-code.html#compile-your-code","text":"There are many ways to compile code for kilobots. This guide presents two of them. Note The following methods have mostly been tested on MacOS Big Sur . If you experience any problem, please consider visiting this quick-start wiki or this guide from the official website (go to 'advanced use' in the 'documentation' section). Both of those websites where used to write this guide.","title":"Compile your code"},{"location":"guides/compile-your-code.html#compiling-your-code-the-easy-way","text":"The kilobotics website provides a simple online editor to write code for kilobots. Once logged in with your Dropbox account, you can access the editor, create new programs and save them. To compile your program, just click the green compile button. A .hex file with the same name as your .c file should appear in the KiloEdit directory of your dropbox. Warning Kilobotics' online editor has aged and is not really maintained anymore. Depending on your operating system, browser or dropbox account and configurations, the editor may not work properly. If this is your case, please use the alternative method presented below.","title":"Compiling your code - the easy way"},{"location":"guides/compile-your-code.html#compiling-your-code-the-less-easy-way","text":"If the kilobotics' online editor doesn't work or doesn't suit your needs, you can still go for the tough method : compiling the code manually. The goal of this tutorial is to get you a simple command-line utility to easily compile your different programs. Warning The following method may not work with Windows operating systems. We suggest that Windows users use a virtual machine running Linux.","title":"Compiling your code - the less-easy way"},{"location":"guides/compile-your-code.html#step-1-install-avr-compilator","text":"","title":"Step 1 : install AVR compilator"},{"location":"guides/compile-your-code.html#for-linux-using-apt","text":"Run the following command in the terminal : sudo apt-get install avr-libc gcc-avr avrdude","title":"For Linux using apt"},{"location":"guides/compile-your-code.html#for-macos-using-homebrew","text":"Run the following command in the terminal : brew tap osx-cross/avr brew install avr-gcc","title":"For MacOS using homebrew"},{"location":"guides/compile-your-code.html#step-2-download-the-template-code","text":"To get the task simpler, download this file . It contains a shell script that will take care of library dependencies and allow us to compile code with just one command.","title":"Step 2 : download the template code"},{"location":"guides/compile-your-code.html#step-3-place-your-files-inside-the-template-directory","text":"Place your files inside the 'TemplateForCompiling' directory. They should now be in the same directory as compileCode.sh .","title":"Step 3 : place your files inside the template directory"},{"location":"guides/compile-your-code.html#step-4-compile-with-one-command","text":"Open a terminal window and navigate inside the 'TemplateForCompiling' directory with the cd command. Type the following command : ./compileCode.sh your-file Note Replace 'your-file' by the real name of the file you want to compile. Note Note how we didn't put the .c extension at the end of the file name.","title":"Step 4 : compile with one command"},{"location":"guides/compile-your-code.html#we-are-done","text":"The .hex file corresponding to your program should now appear inside the 'TemplateForCompiling/build/' directory. If anything went wrong, refer to the error message returned by the compileCode.sh script. If your code contains syntaxical errors, they will be listed there.","title":"We are done !"},{"location":"guides/compile-your-code.html#compiling-your-code-the-windows-hard-way","text":"If the kilobotics' online editor doesn't work or doesn't suit your needs and that you are a windows\u2019 user who doesn't want to use a virtual machine, this way is for you. The goal of this tutorial is to get you a simplified guide to compile on windows with Eclipse IDE and the WinAVR .","title":"Compiling your code - the windows' hard way"},{"location":"guides/compile-your-code.html#step-1-install-winavr","text":"Download and install WinAVR. During installation, accept the option to install Programmer\u2019s Notepad.","title":"Step 1 : Install WinAVR"},{"location":"guides/compile-your-code.html#step-2-build-kilolib","text":"Download Kilolib and extract the zipped file. In your text editor of preference, click File -> Open , navigate to the Kilolib directory and open the file blank.c . Click Tools > Make All . Note If all goes well, you should get: Process Exit Code: 0 . The built files are now found under /build in your Kilolib directory. The static library is the file kilolib.a .","title":"Step 2 : Build Kilolib"},{"location":"guides/compile-your-code.html#step-3-install-eclipse-and-plugins","text":"Install Eclipse with c/c++ support, link available here Install the AVR Eclipse plugin by following the instructions here .","title":"Step 3 : Install Eclipse and Plugins"},{"location":"guides/compile-your-code.html#step-4-create-the-project","text":"Open Eclipse and select a workspace. Click File > New > C Project . In the dialog, give your project a name (here we'll assume it's Kilobot ) and under Project Type , select AVR Cross Target Application > Empty Project . Click Next . Uncheck Debug and click Next . In the next dialog ( AVR Target Hardware Properties ), under MCU Type select ATmega328P , and set the MCU Frequency to 8000000 Hz (8 MHz). Click Finish . Create a new source file in your project by right clicking on the project's name > New > Source File . Give this new source file a name, e.g. main.c . Copy and paste into this file the code from blank.c found in the Kilolib directory.","title":"Step 4 : Create the Project"},{"location":"guides/compile-your-code.html#step-5-set-the-header-and-library-file-paths","text":"In your Eclipse project, create two new directories and call them include and lib (to create a new directory, right click on the project name > New > Folder ). Copy all the .h files from the Kilolib directory into the include directory in your project. Copy the kilolib.a file from /build in the Kilolib directory into the new lib directory in your project. Rename the kilolib.a file you just copied into the lib directory to libkilolib.a (i.e. prepend it with \"lib\"). Right click on the project name and click Properties . Go to C/C++ Build -> Settings . Under Tool Settings go to AVR Compiler -> Directories . Under Include Paths (-I) add a new path. Click Workspace and navigate to the include directory in your project. Click OK . Still under C/C++ Build -> Settings , go to AVR C Linker -> Libraries . Under Libraries Path (-L) add a new path. Click Workspace and navigate to the lib directory in your project. Click OK . Under Libraries (-l) add a library and type: kilolib .","title":"Step 5 : Set the Header and Library File Paths"},{"location":"guides/compile-your-code.html#step-6-build-your-code-and-upload-it-to-a-kilobot","text":"Close the settings - you\u2019re now good to go. Build the project by pressing Ctrl+B (or going to Project -> Build All ). A Release directory will be created in your project, and this will contain the object code file (aka \"hex file\"), Kilobot.hex . You can now upload the hex file onto your Kilobot robot using the KiloGUI tool . Note When starting a new project, you might want to rename a copy of your boilerplate project. Apart from renaming the directory, you also need to open each of the files .cproject and .project , and do a Search and Replace operation from the old (boilerplate) project name to your desired new one. If you want the complete guide or if you have some unexpected results you can click here","title":"Step 6 : Build Your Code and Upload it to a Kilobot"},{"location":"guides/getting-started.html","text":"Getting started with kilobots Here is a simple guide to get started with kilobots. Turning the kilobot on and off On the right side of the front leg are two pins. You probably also have a small red connector for those two pins. By placing the connector on the two pins, you turn the kilobot on and it should blink green. To turn the kilobot off , simply remove the connector. Note As not to lose the connector, you can simply place it on one pin. Warning Be sure not to place the connectors on the two pins that are on the left side of the front leg, as those pins are intended for the debugging cable. What the kilobot is made of As you can see in the pictures above, one kilobot mainly has : 3 legs 2 rumble motors 1 LED a group of 2 power pins a group of 2 debug pins an IR transmitter an IR sensor a battery and a charging hook What the kilobot is up to Kilobots were designed to be very cheap, but are therefore very limited. They can perform simple tasks involving small movements, basic communication and distance sensing. However, as they move using vibrations, they can't have reliable feedback of the movement executed. This makes it impossible to know neither their position nor their orientation. The lack of a second IR sensor also makes it impossible to know the position or orientation of the nearby kilobots. Using KiloGUI The kilobots come with a utility app to do various tasks with them, such as calibration, program transfer, debugging or execution control. You can download KiloGUI at the download section of the kilobotics website . To use KiloGUI, you will have to place the head controller of the kilobots on top of or beside the concerned kilobots and connect it to your PC. Connection with the kilobot should be instantaneous. KILOGUI did not work ? It\u2019s possible that your OHC ( Over-Head Controller) is not recognized by the Kiloguide interface, so you will need to modify your driver. Here is the procedure to follow : install the software \u201cZadig\u201d . Start it Click on the \u201cOptions\u201d and next select \u201cList All Deveices\u201d Now Zadig sofware would be like this Select \u201cLUFA AVRISP MkIIClone\u201d and \u201clibusb-win32 (V1.2.6.0)\u201d Click \u00ab Replace Drive\u00bb (or \u201cReinstall Driver\u201d if already done once) or Select \u201cFT232R USB UART\u201d and \u201clibusb-win32 (V1.2.6.0)\u201d And that\u2019s all ! You can now close Zadig and retry to use KILOGUI with the OHC. If you want to see the original guide for this issue go here Checking the battery of a kilobot You can check the battery power of the kilobot by using the KiloGUI interface. Simply press the \"Voltage\" button and the kilobot LED should light up. The color of the LED indicates the battery power : green means \"fully charged\" and red means \"barely charged\". Charging the kilobots The kilobots come with a charging bar where you can hang up to ten kilobots. Connect the charger to a power supply, then turn the kilobots on and hang them to the charger. The hook of the kilobot should be hung to the upper bar and the two rear legs of the kilobot should touch the lower bar. Calibrating a kilobot After pressing the \"calibrate\" button of KiloGUI, the following window should appear : With this window, you can give each kilobot a unique ID and specific calibration values . The \"test\" button allows you to see the change in the kilobot's motion. From there you can adjust the values so that the kilobot is able to go straight and turn right and left reliably. When you're done, don't forget to save the parameters before you close the window.","title":"Getting started "},{"location":"guides/getting-started.html#getting-started-with-kilobots","text":"Here is a simple guide to get started with kilobots.","title":"Getting started with kilobots"},{"location":"guides/getting-started.html#turning-the-kilobot-on-and-off","text":"On the right side of the front leg are two pins. You probably also have a small red connector for those two pins. By placing the connector on the two pins, you turn the kilobot on and it should blink green. To turn the kilobot off , simply remove the connector. Note As not to lose the connector, you can simply place it on one pin. Warning Be sure not to place the connectors on the two pins that are on the left side of the front leg, as those pins are intended for the debugging cable.","title":"Turning the kilobot on and off"},{"location":"guides/getting-started.html#what-the-kilobot-is-made-of","text":"As you can see in the pictures above, one kilobot mainly has : 3 legs 2 rumble motors 1 LED a group of 2 power pins a group of 2 debug pins an IR transmitter an IR sensor a battery and a charging hook","title":"What the kilobot is made of"},{"location":"guides/getting-started.html#what-the-kilobot-is-up-to","text":"Kilobots were designed to be very cheap, but are therefore very limited. They can perform simple tasks involving small movements, basic communication and distance sensing. However, as they move using vibrations, they can't have reliable feedback of the movement executed. This makes it impossible to know neither their position nor their orientation. The lack of a second IR sensor also makes it impossible to know the position or orientation of the nearby kilobots.","title":"What the kilobot is up to"},{"location":"guides/getting-started.html#using-kilogui","text":"The kilobots come with a utility app to do various tasks with them, such as calibration, program transfer, debugging or execution control. You can download KiloGUI at the download section of the kilobotics website . To use KiloGUI, you will have to place the head controller of the kilobots on top of or beside the concerned kilobots and connect it to your PC. Connection with the kilobot should be instantaneous.","title":"Using KiloGUI"},{"location":"guides/getting-started.html#kilogui-did-not-work","text":"It\u2019s possible that your OHC ( Over-Head Controller) is not recognized by the Kiloguide interface, so you will need to modify your driver. Here is the procedure to follow : install the software \u201cZadig\u201d . Start it Click on the \u201cOptions\u201d and next select \u201cList All Deveices\u201d Now Zadig sofware would be like this Select \u201cLUFA AVRISP MkIIClone\u201d and \u201clibusb-win32 (V1.2.6.0)\u201d Click \u00ab Replace Drive\u00bb (or \u201cReinstall Driver\u201d if already done once) or Select \u201cFT232R USB UART\u201d and \u201clibusb-win32 (V1.2.6.0)\u201d And that\u2019s all ! You can now close Zadig and retry to use KILOGUI with the OHC. If you want to see the original guide for this issue go here","title":"KILOGUI did not work ?"},{"location":"guides/getting-started.html#checking-the-battery-of-a-kilobot","text":"You can check the battery power of the kilobot by using the KiloGUI interface. Simply press the \"Voltage\" button and the kilobot LED should light up. The color of the LED indicates the battery power : green means \"fully charged\" and red means \"barely charged\".","title":"Checking the battery of a kilobot"},{"location":"guides/getting-started.html#charging-the-kilobots","text":"The kilobots come with a charging bar where you can hang up to ten kilobots. Connect the charger to a power supply, then turn the kilobots on and hang them to the charger. The hook of the kilobot should be hung to the upper bar and the two rear legs of the kilobot should touch the lower bar.","title":"Charging the kilobots"},{"location":"guides/getting-started.html#calibrating-a-kilobot","text":"After pressing the \"calibrate\" button of KiloGUI, the following window should appear : With this window, you can give each kilobot a unique ID and specific calibration values . The \"test\" button allows you to see the change in the kilobot's motion. From there you can adjust the values so that the kilobot is able to go straight and turn right and left reliably. When you're done, don't forget to save the parameters before you close the window.","title":"Calibrating a kilobot"},{"location":"guides/guide-index.html","text":"Guides The KiloGuide currently presents 5 guides. Getting started with kilobots Learn how to turn your kilobots on and off. Discover the components of a kilobot, what it can do with them. Calibrate your kilobots. Coding for kilobots Learn the basics of robot programming, which language and which code templates are used to write programs for kilobots. Compile your code Learn how to convert your code into an executable file that will be read by your kilobots. Transfer and run your program Learn how to transfer the executable file into your kilobots, start, pause and stop the program. Use the debug feature Learn how to use the simple debug feature with kilobots, to know what is not working in your programs. Use an emulator Learn how to use and install an emulator to test your code everywhere without kilobot.","title":"Guides summary "},{"location":"guides/guide-index.html#guides","text":"The KiloGuide currently presents 5 guides.","title":"Guides"},{"location":"guides/guide-index.html#getting-started-with-kilobots","text":"Learn how to turn your kilobots on and off. Discover the components of a kilobot, what it can do with them. Calibrate your kilobots.","title":"Getting started with kilobots"},{"location":"guides/guide-index.html#coding-for-kilobots","text":"Learn the basics of robot programming, which language and which code templates are used to write programs for kilobots.","title":"Coding for kilobots"},{"location":"guides/guide-index.html#compile-your-code","text":"Learn how to convert your code into an executable file that will be read by your kilobots.","title":"Compile your code"},{"location":"guides/guide-index.html#transfer-and-run-your-program","text":"Learn how to transfer the executable file into your kilobots, start, pause and stop the program.","title":"Transfer and run your program"},{"location":"guides/guide-index.html#use-the-debug-feature","text":"Learn how to use the simple debug feature with kilobots, to know what is not working in your programs.","title":"Use the debug feature"},{"location":"guides/guide-index.html#use-an-emulator","text":"Learn how to use and install an emulator to test your code everywhere without kilobot.","title":"Use an emulator"},{"location":"guides/transfer-and-run-your-program.html","text":"Transfer and run your programs Transfer a program to your kilobots Once you have successfully compiled your program, it's time to transfer it! To do so, we are going to use this part of the KiloGUI interface : Use the [select file] button to select the .hex file you will transfer into the kilobots. Here, we selected the body-1-OL.hex file. Be sure that KiloGUI is connected to the kilobots by hitting the Bootload button. The kilobots' LEDs should now be blue. You can then click the Upload button to start the transfer. The kilobots will blink green and blue alternatively during this process. Wait a few seconds. When the program has been transferred, the kilobots will get back to blink green slowly, indicating that they are ready to start the execution ! Warning If a kilobot only blinks blue and green for a short amount of time before turning off during transfer, a problem has occurred. Ensure your code does not contain syntaxical errors (if so, they should be displayed during compilation). Be sure the voltage of the kilobot is not too low (aka not red). Check that the ground on which the kilobot is placed is reflecting enough for IR communication. If none of these solutions work, try updating the kilobot firmware. Note If you experience trouble as above, consider trying different programs, kilobots and reflecting surfaces to identify the root of the problem. Run the program If the program transfer was successful, it's now time to start the execution! For this section, we are going to focus on this part of the KiloGUI interface : To start the execution, just press the Run button. The Pause button will stop the execution until the Run button is hit again. To make the kilobots go back to the starting point of the program, use the Reset button. The other buttons are not really linked to the program execution. Sleep will put the kilobots to sleep, Voltage will display the battery level using the kilobots' LEDs and LedToggle can be used to ensure that the connection between the kilobots and the head controller has been well established.","title":"Transfer and run your program"},{"location":"guides/transfer-and-run-your-program.html#transfer-and-run-your-programs","text":"","title":"Transfer and run your programs"},{"location":"guides/transfer-and-run-your-program.html#transfer-a-program-to-your-kilobots","text":"Once you have successfully compiled your program, it's time to transfer it! To do so, we are going to use this part of the KiloGUI interface : Use the [select file] button to select the .hex file you will transfer into the kilobots. Here, we selected the body-1-OL.hex file. Be sure that KiloGUI is connected to the kilobots by hitting the Bootload button. The kilobots' LEDs should now be blue. You can then click the Upload button to start the transfer. The kilobots will blink green and blue alternatively during this process. Wait a few seconds. When the program has been transferred, the kilobots will get back to blink green slowly, indicating that they are ready to start the execution ! Warning If a kilobot only blinks blue and green for a short amount of time before turning off during transfer, a problem has occurred. Ensure your code does not contain syntaxical errors (if so, they should be displayed during compilation). Be sure the voltage of the kilobot is not too low (aka not red). Check that the ground on which the kilobot is placed is reflecting enough for IR communication. If none of these solutions work, try updating the kilobot firmware. Note If you experience trouble as above, consider trying different programs, kilobots and reflecting surfaces to identify the root of the problem.","title":"Transfer a program to your kilobots"},{"location":"guides/transfer-and-run-your-program.html#run-the-program","text":"If the program transfer was successful, it's now time to start the execution! For this section, we are going to focus on this part of the KiloGUI interface : To start the execution, just press the Run button. The Pause button will stop the execution until the Run button is hit again. To make the kilobots go back to the starting point of the program, use the Reset button. The other buttons are not really linked to the program execution. Sleep will put the kilobots to sleep, Voltage will display the battery level using the kilobots' LEDs and LedToggle can be used to ensure that the connection between the kilobots and the head controller has been well established.","title":"Run the program"},{"location":"guides/use-an-emulator.html","text":"Use an Emulator Why use an Emulator? Using an emulator instead of a real kilobot can be a real benefit for your project. But depending on your case, some disadvantages could be very disabling. So, to help you choose whether using an emulator or not, here is a non-exhaustive list of Pros, Neutral and Cons Pros : fact that are at your advantage. You can use the emulator wherever you want. You are not dependent on the kilobot's battery. You are not limited by the amount of your kilobots. You are not limited by the integrity problem of your kilobots. Testing on an emulator is generally faster than testing on kilobot. It is easier to debug the code because you can use assert.h . Neutral : Pros or Cons depending in your case. You will be in a perfect condition to test. Cons : fact that are at your disadvantage. You have to choose your emulator. You have to set up your emulator and its config. You have to learn the caracteristique of your emulator and how to use it. When your project works in your emulator you have to adapt your code for your kilobots. Note This guide only talks about Kilombo and Argos3 . However, you are advised to look for other emulators to find the one that best suits your project. What Emulator choose To choose what emulator you will use, you need to know their caracteristiques to compare them. To learn their caracteristique, you have to read the documentation of the emulator. But you also have to test the emulator by yourself to see if it's really what you are need. Here his an example with Kilombo and Argos3 : Warning The Exemple is based on the Kilombo and Argos3 documentation and my personal experience! This exemple isn't exhaustive and can be invalided by an update of one of the emulator! Pleas read the documentation and test by youself before make your choice! Kilombo Architecture Single-thread, single process wrapper around kilolib.h Robots must run the same behavior Global variables cannot be used to contain state Models Only model offered is the Kilobot Motion is kinematics with simple overlap resolution Robots cannot push other objects Communication neglects obstructions Message drop has uniform probability Features pause button (pause the simulation) speed button (button to accelerate or descelerate the simulation) possibilities to move the kilobots with the mouse during the simulation ARGoS Architecture Multi-thread, multi-process architecture Robots can run different behaviors Global variables can be used to contain state Models Models of Kilobot, other robots, boxes, cylinders Motion is full 2D dynamics Robots can push other objects Communication considers obstruction Message drop considers local density Features pause button (pause the simulation) select frame button (button to move the simulation frame by frame) As you can see, although these two are made to emule the kilobots, they didn't make it with the same methods! So, if you have a project with different code working together, it would be better to use Argos3 because if his multy threading. But if you have only one code in all your kilobots and that you want to test them in different layout, Kilombo would be better because of his speed and deplacement feature. What emulator you choose depends of your goal(s)! How to install an emulator? Argos3 First install Argos3 version version 3.0.0-beta52 or higher. Next go where you want to setup your Argos file and in the command terminal use the following command : mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release ../src make sudo make install Congratulations, you have installed Argos3-Kilobot! You can test your installation by launching a preinstalled project. To do it, go to the file where you installed the build and the src and use in the terminal : argos3 -c src/examples/experiments/kilobot_orbit.argos Warning Since each emulator needs a specific installation, this explanation only concerne Argos3. To know more about the installation of your emulator, read the documentation or the readme.md / readme.txt How to Use an emulator? Argos3 To add a new project follow the next steps: Go to the file src/example/behaviors . Place your .C here and add his name in the CMakeLists.txt like this add_executable(FileName FileName.c . Next return in src/example and place your config file. Execute the command make in src/ . When the build is over execute the command argos3 -c examples/experiments/NameConfigFile.argos And that is all! Now a new window would be open. You just have to start the emulation with the button start Warning Each emulator works with his own rules. To know them, you can read the documentation but you must above all make a lot of effort. Setup you Config file When you use an emulator you need to choose the placement of your kilobot. For this we use a config file. In this section you will learn how to set up this config file for your emulator. Argos3 Copy and paste a pre-existing config file in src/examples/experiments/ . Rename the copy by the name of your program. Next open the file and go the \" Arena Configuration \" section Normally, in the <arena> balise there is this : This represents the placement of one kilobot. For each kilobot you want to add you have to : change his id <kilobot id=\"kb1\"> ( each id must be unique) change his position and orientation <body position=\"0,0,0\" orientation=\"0,0,0\" /> (two kilobot can not be at the same placement). choose the program that you want it to do <controller config=\"kbc\" />> . Next go to the \" Controllers\" section. Normally, in the <controllers> balise there is this : For each different program you want to use you have to : setup his name <kilobot_controller id=\"kbc\"> change his path behavior=\"build/examples/behaviors/move_to_light\" /> That is all! Note I advise you to develop a program if you want to make your tests with a lot of kilobot. Especially if you want to make geometrical form.","title":"Use an Emulator "},{"location":"guides/use-an-emulator.html#use-an-emulator","text":"","title":"Use an Emulator"},{"location":"guides/use-an-emulator.html#why-use-an-emulator","text":"Using an emulator instead of a real kilobot can be a real benefit for your project. But depending on your case, some disadvantages could be very disabling. So, to help you choose whether using an emulator or not, here is a non-exhaustive list of Pros, Neutral and Cons","title":"Why use an Emulator?"},{"location":"guides/use-an-emulator.html#pros-fact-that-are-at-your-advantage","text":"You can use the emulator wherever you want. You are not dependent on the kilobot's battery. You are not limited by the amount of your kilobots. You are not limited by the integrity problem of your kilobots. Testing on an emulator is generally faster than testing on kilobot. It is easier to debug the code because you can use assert.h .","title":"Pros : fact that are at your advantage."},{"location":"guides/use-an-emulator.html#neutral-pros-or-cons-depending-in-your-case","text":"You will be in a perfect condition to test.","title":"Neutral : Pros or Cons depending in your case."},{"location":"guides/use-an-emulator.html#cons-fact-that-are-at-your-disadvantage","text":"You have to choose your emulator. You have to set up your emulator and its config. You have to learn the caracteristique of your emulator and how to use it. When your project works in your emulator you have to adapt your code for your kilobots. Note This guide only talks about Kilombo and Argos3 . However, you are advised to look for other emulators to find the one that best suits your project.","title":"Cons : fact that are at your disadvantage."},{"location":"guides/use-an-emulator.html#what-emulator-choose","text":"To choose what emulator you will use, you need to know their caracteristiques to compare them. To learn their caracteristique, you have to read the documentation of the emulator. But you also have to test the emulator by yourself to see if it's really what you are need. Here his an example with Kilombo and Argos3 : Warning The Exemple is based on the Kilombo and Argos3 documentation and my personal experience! This exemple isn't exhaustive and can be invalided by an update of one of the emulator! Pleas read the documentation and test by youself before make your choice!","title":"What Emulator choose"},{"location":"guides/use-an-emulator.html#kilombo","text":"Architecture Single-thread, single process wrapper around kilolib.h Robots must run the same behavior Global variables cannot be used to contain state Models Only model offered is the Kilobot Motion is kinematics with simple overlap resolution Robots cannot push other objects Communication neglects obstructions Message drop has uniform probability Features pause button (pause the simulation) speed button (button to accelerate or descelerate the simulation) possibilities to move the kilobots with the mouse during the simulation","title":"Kilombo"},{"location":"guides/use-an-emulator.html#argos","text":"Architecture Multi-thread, multi-process architecture Robots can run different behaviors Global variables can be used to contain state Models Models of Kilobot, other robots, boxes, cylinders Motion is full 2D dynamics Robots can push other objects Communication considers obstruction Message drop considers local density Features pause button (pause the simulation) select frame button (button to move the simulation frame by frame) As you can see, although these two are made to emule the kilobots, they didn't make it with the same methods! So, if you have a project with different code working together, it would be better to use Argos3 because if his multy threading. But if you have only one code in all your kilobots and that you want to test them in different layout, Kilombo would be better because of his speed and deplacement feature. What emulator you choose depends of your goal(s)!","title":"ARGoS"},{"location":"guides/use-an-emulator.html#how-to-install-an-emulator","text":"","title":"How to install an emulator?"},{"location":"guides/use-an-emulator.html#argos3","text":"First install Argos3 version version 3.0.0-beta52 or higher. Next go where you want to setup your Argos file and in the command terminal use the following command : mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release ../src make sudo make install Congratulations, you have installed Argos3-Kilobot! You can test your installation by launching a preinstalled project. To do it, go to the file where you installed the build and the src and use in the terminal : argos3 -c src/examples/experiments/kilobot_orbit.argos Warning Since each emulator needs a specific installation, this explanation only concerne Argos3. To know more about the installation of your emulator, read the documentation or the readme.md / readme.txt","title":"Argos3"},{"location":"guides/use-an-emulator.html#how-to-use-an-emulator","text":"","title":"How to Use an emulator?"},{"location":"guides/use-an-emulator.html#argos3_1","text":"To add a new project follow the next steps: Go to the file src/example/behaviors . Place your .C here and add his name in the CMakeLists.txt like this add_executable(FileName FileName.c . Next return in src/example and place your config file. Execute the command make in src/ . When the build is over execute the command argos3 -c examples/experiments/NameConfigFile.argos And that is all! Now a new window would be open. You just have to start the emulation with the button start Warning Each emulator works with his own rules. To know them, you can read the documentation but you must above all make a lot of effort.","title":"Argos3"},{"location":"guides/use-an-emulator.html#setup-you-config-file","text":"When you use an emulator you need to choose the placement of your kilobot. For this we use a config file. In this section you will learn how to set up this config file for your emulator.","title":"Setup you Config file"},{"location":"guides/use-an-emulator.html#argos3_2","text":"Copy and paste a pre-existing config file in src/examples/experiments/ . Rename the copy by the name of your program. Next open the file and go the \" Arena Configuration \" section Normally, in the <arena> balise there is this : This represents the placement of one kilobot. For each kilobot you want to add you have to : change his id <kilobot id=\"kb1\"> ( each id must be unique) change his position and orientation <body position=\"0,0,0\" orientation=\"0,0,0\" /> (two kilobot can not be at the same placement). choose the program that you want it to do <controller config=\"kbc\" />> . Next go to the \" Controllers\" section. Normally, in the <controllers> balise there is this : For each different program you want to use you have to : setup his name <kilobot_controller id=\"kbc\"> change his path behavior=\"build/examples/behaviors/move_to_light\" /> That is all! Note I advise you to develop a program if you want to make your tests with a lot of kilobot. Especially if you want to make geometrical form.","title":"Argos3"},{"location":"guides/use-the-debug-feature.html","text":"Use the debug features Sometimes the code can produce some unexpected behaviors. To help to find out the causes, kilobots are equipped with a very basic debugging feature. How to set up the debug feature Step 1 : Include debug.h In the first lines of your program, add the following lines : #define DEBUG #include <debug.h> Step 2 : Initialize the debugger In the main function of your program, add the following line between kilo_init() and kilo_start() : kilo_init(); debug_init(); // This line is new kilo_start(setup, loop); Step 3 : Add printf() s Debugging code on kilobots is actually just using the common C function printf() to send a string to the head controller and therefore the computer. You can use it to trace the execution of your program or to check the value of a variable. printf(\"%d\", kilo_ticks); // Example printing the value of kilo_ticks Step 4 : Connect the kilobot to the head controller That's where the two pins located on the left side of the kilobot's front leg come into play. Connect those pins to the pins of the head controller like presented in these images : Note On some head controller, the 2 debug pins are located under the board. The white end of the connector cable needs to connect to the head, and the black end will connect to the kilobot. Step 5 : Open the Serial Input window After you transfer your compiled program to the kilobot, open the serial input window by clicking the Serial Input button. There you will see every message sent by the kilobot via the printf() function. We are done ! A complete example Here is a basic \"Hello world!\" program to test the debugging feature. You can download the source file here . #include <kilolib.h> #define DEBUG #include <debug.h> void setup() { printf(\"Hello world!\"); } void loop() { return; } int main() { kilo_init(); debug_init(); kilo_start(setup, loop); return 0; }","title":"Use the debug feature"},{"location":"guides/use-the-debug-feature.html#use-the-debug-features","text":"Sometimes the code can produce some unexpected behaviors. To help to find out the causes, kilobots are equipped with a very basic debugging feature.","title":"Use the debug features"},{"location":"guides/use-the-debug-feature.html#how-to-set-up-the-debug-feature","text":"","title":"How to set up the debug feature"},{"location":"guides/use-the-debug-feature.html#step-1-include-debugh","text":"In the first lines of your program, add the following lines : #define DEBUG #include <debug.h>","title":"Step 1 : Include debug.h"},{"location":"guides/use-the-debug-feature.html#step-2-initialize-the-debugger","text":"In the main function of your program, add the following line between kilo_init() and kilo_start() : kilo_init(); debug_init(); // This line is new kilo_start(setup, loop);","title":"Step 2 : Initialize the debugger"},{"location":"guides/use-the-debug-feature.html#step-3-add-printfs","text":"Debugging code on kilobots is actually just using the common C function printf() to send a string to the head controller and therefore the computer. You can use it to trace the execution of your program or to check the value of a variable. printf(\"%d\", kilo_ticks); // Example printing the value of kilo_ticks","title":"Step 3 : Add printf()s"},{"location":"guides/use-the-debug-feature.html#step-4-connect-the-kilobot-to-the-head-controller","text":"That's where the two pins located on the left side of the kilobot's front leg come into play. Connect those pins to the pins of the head controller like presented in these images : Note On some head controller, the 2 debug pins are located under the board. The white end of the connector cable needs to connect to the head, and the black end will connect to the kilobot.","title":"Step 4 : Connect the kilobot to the head controller"},{"location":"guides/use-the-debug-feature.html#step-5-open-the-serial-input-window","text":"After you transfer your compiled program to the kilobot, open the serial input window by clicking the Serial Input button. There you will see every message sent by the kilobot via the printf() function. We are done !","title":"Step 5 : Open the Serial Input window"},{"location":"guides/use-the-debug-feature.html#a-complete-example","text":"Here is a basic \"Hello world!\" program to test the debugging feature. You can download the source file here . #include <kilolib.h> #define DEBUG #include <debug.h> void setup() { printf(\"Hello world!\"); } void loop() { return; } int main() { kilo_init(); debug_init(); kilo_start(setup, loop); return 0; }","title":"A complete example"},{"location":"tutorials/tuto-index.html","text":"Tutorials Kilobots This guide currently presents 5 easy and diverse tutorials. Race Around the World Number of kilobots : 1 Topic : basic program and movement Learn the basics of robot programming with one single kilobot. Write a simple program to turn on its LED and make it move along a race track. Full Metal Kilobot Number of kilobots : 2 Topic : messages and communication Get into a more complex program, using communication between two kilobots in a creative way. One of the kilobots is the instructor, yelling orders to the rookie, which must then execute them more or less precisely. King-o-bot's Games Number of kilobots : 2 Topic : distance measuring In this tutorial inspired by the medieval knight's tournaments, the kilobots must fight in duel, going one toward the other at astounding speeds. The first to freak out loses and won't be King-o-bot's great champion! Morphogenetics Number of kilobots : arbitrary Topic : collective organization In living creatures' bodies, a cell can sometimes approximate its distance to another cell by analysing the neighbouring concentration of chemicals produced by that cell. Let's put this idea in practice with kilobots! Rush Hour Number of kilobots : arbitrary Topic : collective behavior In this tutorial, a lot of kilobots are placed in a limited space. As they move around randomly, they must display different colors depending on the number of kilobots they detect around them. The goal is to obtain some heat-map of the kilobot concentrations at a high scale.","title":"Tutorials summary"},{"location":"tutorials/tuto-index.html#tutorials-kilobots","text":"This guide currently presents 5 easy and diverse tutorials.","title":"Tutorials Kilobots"},{"location":"tutorials/tuto-index.html#race-around-the-world","text":"Number of kilobots : 1 Topic : basic program and movement Learn the basics of robot programming with one single kilobot. Write a simple program to turn on its LED and make it move along a race track.","title":"Race Around the World"},{"location":"tutorials/tuto-index.html#full-metal-kilobot","text":"Number of kilobots : 2 Topic : messages and communication Get into a more complex program, using communication between two kilobots in a creative way. One of the kilobots is the instructor, yelling orders to the rookie, which must then execute them more or less precisely.","title":"Full Metal Kilobot"},{"location":"tutorials/tuto-index.html#king-o-bots-games","text":"Number of kilobots : 2 Topic : distance measuring In this tutorial inspired by the medieval knight's tournaments, the kilobots must fight in duel, going one toward the other at astounding speeds. The first to freak out loses and won't be King-o-bot's great champion!","title":"King-o-bot's Games"},{"location":"tutorials/tuto-index.html#morphogenetics","text":"Number of kilobots : arbitrary Topic : collective organization In living creatures' bodies, a cell can sometimes approximate its distance to another cell by analysing the neighbouring concentration of chemicals produced by that cell. Let's put this idea in practice with kilobots!","title":"Morphogenetics"},{"location":"tutorials/tuto-index.html#rush-hour","text":"Number of kilobots : arbitrary Topic : collective behavior In this tutorial, a lot of kilobots are placed in a limited space. As they move around randomly, they must display different colors depending on the number of kilobots they detect around them. The goal is to obtain some heat-map of the kilobot concentrations at a high scale.","title":"Rush Hour"},{"location":"tutorials/tuto1.html","text":"Race around the world source code of this tutorial Summary In this tutorial, we are going to discover the basics of kilobot programming. This simple bunch of code will make a single kilobot race along a track in loop. The code in this tutorial is written for this racetrack . The kilobot starts the race with its front leg on the red point. Note that you can adapt it to any race track you want. Note We suggest you draw the racetrack onto the kilobot table using a whiteboard marker, so as to not make the robot run on a harsh surface. What you will learn Basic template for a kilobot program How to make the kilobot flash color with set_color() How to make the kilobot move with set_motors() Basics If you have already read the coding for kilobots guide, you already know that a kilobot program is divided in two main parts : the setup() function and the loop() function. The setup() function is only executed once, at the very start of the execution, and the loop() function is executed again and again until the kilobot is told to stop. The following sections will illustrate how these two components work to build a simple behavior for the kilobot. The setup() function Before the kilobot starts racing along the track, we are going to make it flash like the flashlight at the beginning of a real race. As this code is only ran once at the start, we are going to place it in the setup() function : void setup() { // Blinks red, yellow and green before startup set_color(RGB(1,0,0)); // red delay(1000); set_color(RGB(1,1,0)); // yellow delay(1000); set_color(RGB(0,1,0)); // green } Note The delay() function stops the execution of the program, but it doesn't stop the LED from shining. It is useful to turn the LED on for a certain amount of time. The loop() function The sequence of actions that a kilobot must do to race a single loop around the track will be placed here. void loop() { // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); // Turns left spinup_motors(); set_motors(kilo_turn_left, kilo_straight_right/2); delay(5000); // Goes straight again spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(4000); // Turns right spinup_motors(); set_motors(kilo_straight_left/2, kilo_turn_right); delay(5000); // Goes straight to get back to the race starting point spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); } To make the kilobot move, we use the set_motors() function. Before calling it, we must call the spinup_motors() function to avoid static friction effects. The two arguments of the set_motors() function indicate the power of each motor of the kilobot. Those values can go from 0 (off) to 255 (full speed). To take calibration into account, it is recommended to use the predefined values kilo_straight_left , kilo_straight_right , kilo_turn_left and kilo_turn_right rather than some raw numbers. Note Just as it did for the LED, the delay() function makes it possible to define the amount of time during which the motors must work. It doesn't stop the movement of the kilobot Note See how we used kilo_straight_left/2 and kilo_straight_right/2 when turning. This enables us to manage the angle of turn. The more we divide the value, the tighter the turn becomes. Replacing those expressions by 0 would give the tightest turns. Warning Kilobots movement depends on a lot of factors and is impredictable by nature. The values used in the delay() or set_motors() functions might be changed for them to work in your particular environment. The main() function We are almost done ! At this point, we only have to define the entry-point of our program : the main() function. int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } The main() function must always call kilo_init() , then kilo_start() in order to start the program. We are done ! You can now admire your kilobot burn the tarmac ! Well, it might not be that impressive. The kilobots were probably not designed as racing machines. But fair enough, it at least made you learn the basics of programming for kilobots !","title":"Race Around the World"},{"location":"tutorials/tuto1.html#race-around-the-world","text":"source code of this tutorial","title":"Race around the world"},{"location":"tutorials/tuto1.html#summary","text":"In this tutorial, we are going to discover the basics of kilobot programming. This simple bunch of code will make a single kilobot race along a track in loop. The code in this tutorial is written for this racetrack . The kilobot starts the race with its front leg on the red point. Note that you can adapt it to any race track you want. Note We suggest you draw the racetrack onto the kilobot table using a whiteboard marker, so as to not make the robot run on a harsh surface.","title":"Summary"},{"location":"tutorials/tuto1.html#what-you-will-learn","text":"Basic template for a kilobot program How to make the kilobot flash color with set_color() How to make the kilobot move with set_motors()","title":"What you will learn"},{"location":"tutorials/tuto1.html#basics","text":"If you have already read the coding for kilobots guide, you already know that a kilobot program is divided in two main parts : the setup() function and the loop() function. The setup() function is only executed once, at the very start of the execution, and the loop() function is executed again and again until the kilobot is told to stop. The following sections will illustrate how these two components work to build a simple behavior for the kilobot.","title":"Basics"},{"location":"tutorials/tuto1.html#the-setup-function","text":"Before the kilobot starts racing along the track, we are going to make it flash like the flashlight at the beginning of a real race. As this code is only ran once at the start, we are going to place it in the setup() function : void setup() { // Blinks red, yellow and green before startup set_color(RGB(1,0,0)); // red delay(1000); set_color(RGB(1,1,0)); // yellow delay(1000); set_color(RGB(0,1,0)); // green } Note The delay() function stops the execution of the program, but it doesn't stop the LED from shining. It is useful to turn the LED on for a certain amount of time.","title":"The setup() function"},{"location":"tutorials/tuto1.html#the-loop-function","text":"The sequence of actions that a kilobot must do to race a single loop around the track will be placed here. void loop() { // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); // Turns left spinup_motors(); set_motors(kilo_turn_left, kilo_straight_right/2); delay(5000); // Goes straight again spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(4000); // Turns right spinup_motors(); set_motors(kilo_straight_left/2, kilo_turn_right); delay(5000); // Goes straight to get back to the race starting point spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(2000); } To make the kilobot move, we use the set_motors() function. Before calling it, we must call the spinup_motors() function to avoid static friction effects. The two arguments of the set_motors() function indicate the power of each motor of the kilobot. Those values can go from 0 (off) to 255 (full speed). To take calibration into account, it is recommended to use the predefined values kilo_straight_left , kilo_straight_right , kilo_turn_left and kilo_turn_right rather than some raw numbers. Note Just as it did for the LED, the delay() function makes it possible to define the amount of time during which the motors must work. It doesn't stop the movement of the kilobot Note See how we used kilo_straight_left/2 and kilo_straight_right/2 when turning. This enables us to manage the angle of turn. The more we divide the value, the tighter the turn becomes. Replacing those expressions by 0 would give the tightest turns. Warning Kilobots movement depends on a lot of factors and is impredictable by nature. The values used in the delay() or set_motors() functions might be changed for them to work in your particular environment.","title":"The loop() function"},{"location":"tutorials/tuto1.html#the-main-function","text":"We are almost done ! At this point, we only have to define the entry-point of our program : the main() function. int main() { // Initializes hardware kilo_init(); // Starts program kilo_start(setup, loop); return 0; } The main() function must always call kilo_init() , then kilo_start() in order to start the program.","title":"The main() function"},{"location":"tutorials/tuto1.html#we-are-done","text":"You can now admire your kilobot burn the tarmac ! Well, it might not be that impressive. The kilobots were probably not designed as racing machines. But fair enough, it at least made you learn the basics of programming for kilobots !","title":"We are done !"},{"location":"tutorials/tuto2.html","text":"Full Metal Kilobot source code of this tutorial Summary Now that we know the basics, let's tackle the real interesting thing about kilobots : make them communicate. This tutorial is inspired by the military training scenes in Kubrick's \"Full Metal Jacket\" movie . We will use two kilobots : one will be the instructor, the other will be the rookie. Therefore, we are going to write two distinct programs : the instructor's program, generating and sending random training instructions the rookie's program, executing instructions as fast as possible What you will learn How to create a message with the message_t structure How to generate random numbers with the rand_hard() function How to send messages with kilo_message_tx How to receive and read messages with kilo_message_rx Create messages Messages for kilobots are contained in the message_t structure, which has 3 fields : type , from 0 to 127, describing the type of the message. For this tutorial, we will only use the macro NORMAL data , an array of length 9, storing the real content of the message crc , an hash code, computed with the message_crc() function, used to check that data was not corrupted during transmission. We can define a message like this : message_t message; // This message will contain the answer to the ultimate question of life, universe and everything. message.type = NORMAL; message.data[0] = 42; message.crc = message_crc(&message); Create random numbers Kilobots have two functions to generate random numbers : rand_soft() generates a random number from a seed. You can provide a specific seed using the rand_seed() function. rand_hard() generates a random number from the kilobot's hardware, namely its battery precise voltage. As rand_hard() is slower than rand_soft() , it is common to use rand_soft() when we need random numbers multiple times per second. In that situation, we can use rand_hard() inside rand_seed() to initialize the RNG. In this tutorial, we will only use the rand_hard() function as we do not need efficiency. Instructor's program Let's get into the real code ! Instructions The first step is to define a protocol used by the two kilobots to communicate. It seems difficult but it really is fairly simple. We have 3 different possible instructions : \" Show me your war face! \" \u27f6 Light the led \" Turn on yourself x times! \" \u27f6 Set motors to do x turns on itself \" Run x cm and come back! \" \u27f6 Set motors to run x cm, turn around and come back A simple protocol would be : \"Each instruction has an ID, from 1 to 3, stored in the first byte of data . Instructions 2 and 3 have a parameter, stored in the second byte of data .\" So for example, \"Turn on yourself 3 times!\" would translate to the following message : message_t message; message.type = NORMAL; message.data[0] = 2; // Turn on yourself... message.data[1] = 3; // ...3 times! message.crc = message_crc(&message); We can now write a simple program that will generate a random instruction : message_t instruction; int instructionID; int instructionParam; void makeInstruction() { // Creates an instruction to be given to the rookie instruction.type = NORMAL; instruction.data[0] = instructionID; instruction.data[1] = instructionParam; instruction.crc = message_crc(&instruction); } void generateInstruction() { // Gives an instruction to the rookie // Choses the instruction instructionID = (rand_hard() % 3) + 1; // Instructions have a specific number, from 1 to 3 // Depending on the instruction, generates a random parameter switch (instructionID) { case 1: // Rookie must show his war face ! (Turn on his led) instructionParam = 0; break; case 2: // Rookie must run x centimeters, then come back. instructionParam = 3 + (rand_hard() % 8); // Cm to be runned, from 3 to 10 break; case 3: // Rookie must turn around on himself x times. instructionParam = 1 + (rand_hard() % 3); // number of turns, from 1 to 3 break; } makeInstruction(); } Note Note how we put instruction , instructionID and instructionParam as global variables. It makes it possible to access them from anywhere in the code, though we must be careful with the way each part of the program manipulates them. Message handling To handle communication, we need to define two functions. One (commonly named message_tx() ) will be called when sending a message, the other (commonly named message_rx() ) will be called when receiving a message. We also have to define a flag, which is a variable with value 0 or 1 describing the \"state\" of the robot. In our case, the instructionGiven flag tells wether or not an instruction has been given to the rookie. If its value is 0, the instructor should generate and send a new instruction. If it's 1, the instructor waits for the rookie to finish. int instructionGiven = 0; message_t* message_tx() { // This function returns the instruction to send to the rookie return &instruction; } void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie has finished executing his order and is ready for a new one. instructionGiven = 0; } Note Notice the two parameters of the message_rx function. They are mandatory to define the function, but of no use for the instructor. Setup and loop The setup function for the instructor is rather minimalistic, it's even empty in fact. The instructor does not care about anything except yelling orders repeatedly. In the loop function, we will either generate a new instruction or wait for the rookie. When generating a new instruction, the instructor will indicate the instruction chosen by turning on its LED with a specific color. When waiting, the instructor blinks yellow. void setup() { } void loop() { if (!instructionGiven) { // Gives an order. Blinks a specific color depending on the given order generateInstruction(); switch (instructionID) { case 1: set_color(RGB(1,0, 0)); // Blinks red break; case 2: set_color(RGB(0, 1, 0)); // Blinks green break; case 3: set_color(RGB(0, 0, 1)); // Blinks green to break; } delay(500); set_color(RGB(0,0,0)); instructionGiven = 1; // Changes the flag } else { // Waits for the rookie. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } } Note Even if the setup() function is empty, we must define it, as it must be passed to the kilo_start() function. Put it together The only thing left to do is to define the main function. kilo_message_tx and kilo_message_rx are system variables used to specify which function to call when sending/receiving a message. int main() { // initialize hardware kilo_init(); // Registers the function to call when sending a instruction kilo_message_tx = message_tx; // Registers the function to call when rookie says he is ready kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; } Rookie's program Most of the aspects of the rookie's program have already been seen in the instructor's program. In this section, we will only focus on the new things. Message handling Sending messages The rookie must only send a message to say that he is ready, so the message doesn't need to contain any data : the mere fact that he is sending a message already tells the purpose of the message. And as you can see above, the instructor never cares about the content of the message. The rookie will also use a flag to tell wether he is ready for an instruction or not. These facts give the following code : #include <stddef.h> // Defines 'NULL' macro message_t ready; int waitingForInstruction = 0; void setup() { // Waits to be called by the instructor waitingForInstruction = 1; // Initialize the message ready.type = NORMAL; ready.crc = message_crc(&ready); } message_t* message_tx() { // Sends a message if the rookie is ready. If not, sends nothing. if (waitingForInstruction) { return &ready; } return NULL; } Receiving messages As for the instructor's program, the rookie will receive message with the message_rx() function. Here, the msg parameter is useful to retrieve the content of the message : int instructionID = 0; int instructionParam = 0; void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie receives an instruction instructionID = msg->data[0]; instructionParam = msg->data[1]; waitingForInstruction = 0; } The loop In the loop function, the rookie will either execute an instruction, or wait to receive one. When waiting, it blinks yellow. int straightSpeedCalibrator = 1000; // Delay in milliseconds to go straight on 1cm int turningSpeedCalibrator = 5000; // Delay in milliseconds to make 1 turn around void loop() { if (waitingForInstruction) { // Waits for orders. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } else { switch(instructionID) { case 1: // Rookie shows his war face set_color(RGB(0, 1, 1)); delay(500); set_color(RGB(0,0,0)); break; case 2: // Rookie runs x centimeters, then comes back for (int i = 0 ; i < 2 ; i++) { spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(instructionParam * straightSpeedCalibrator); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; case 3: // Rookie turns around on himself x times for (int i = 0 ; i < instructionParam ; i++) { spinup_motors(); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; } waitingForInstruction = 1; delay(2000); // Waits two seconds before executing the next instruction } } Note Notice the use of straightSpeedCalibrator and turningSpeedCalibrator . These variables are used to indicate the time the kilobot takes to do a specific movement. Set them to the most fitting values depending on your kilobot specificities. Put it together The main() function is nothing new at this point: int main() { // Initializes hardware kilo_init(); // Registers the function to call when receiving a instruction kilo_message_rx = message_rx; // Registers the function to call when sending a message kilo_message_tx = message_tx; // Starts program kilo_start(setup, loop); return 0; } We are done ! You can now admire two kilobots in a tough military training. You've mastered the art of communication and are ready to get into the next tutorial !","title":"Full Metal Kilobot"},{"location":"tutorials/tuto2.html#full-metal-kilobot","text":"source code of this tutorial","title":"Full Metal Kilobot"},{"location":"tutorials/tuto2.html#summary","text":"Now that we know the basics, let's tackle the real interesting thing about kilobots : make them communicate. This tutorial is inspired by the military training scenes in Kubrick's \"Full Metal Jacket\" movie . We will use two kilobots : one will be the instructor, the other will be the rookie. Therefore, we are going to write two distinct programs : the instructor's program, generating and sending random training instructions the rookie's program, executing instructions as fast as possible","title":"Summary"},{"location":"tutorials/tuto2.html#what-you-will-learn","text":"How to create a message with the message_t structure How to generate random numbers with the rand_hard() function How to send messages with kilo_message_tx How to receive and read messages with kilo_message_rx","title":"What you will learn"},{"location":"tutorials/tuto2.html#create-messages","text":"Messages for kilobots are contained in the message_t structure, which has 3 fields : type , from 0 to 127, describing the type of the message. For this tutorial, we will only use the macro NORMAL data , an array of length 9, storing the real content of the message crc , an hash code, computed with the message_crc() function, used to check that data was not corrupted during transmission. We can define a message like this : message_t message; // This message will contain the answer to the ultimate question of life, universe and everything. message.type = NORMAL; message.data[0] = 42; message.crc = message_crc(&message);","title":"Create messages"},{"location":"tutorials/tuto2.html#create-random-numbers","text":"Kilobots have two functions to generate random numbers : rand_soft() generates a random number from a seed. You can provide a specific seed using the rand_seed() function. rand_hard() generates a random number from the kilobot's hardware, namely its battery precise voltage. As rand_hard() is slower than rand_soft() , it is common to use rand_soft() when we need random numbers multiple times per second. In that situation, we can use rand_hard() inside rand_seed() to initialize the RNG. In this tutorial, we will only use the rand_hard() function as we do not need efficiency.","title":"Create random numbers"},{"location":"tutorials/tuto2.html#instructors-program","text":"Let's get into the real code !","title":"Instructor's program"},{"location":"tutorials/tuto2.html#instructions","text":"The first step is to define a protocol used by the two kilobots to communicate. It seems difficult but it really is fairly simple. We have 3 different possible instructions : \" Show me your war face! \" \u27f6 Light the led \" Turn on yourself x times! \" \u27f6 Set motors to do x turns on itself \" Run x cm and come back! \" \u27f6 Set motors to run x cm, turn around and come back A simple protocol would be : \"Each instruction has an ID, from 1 to 3, stored in the first byte of data . Instructions 2 and 3 have a parameter, stored in the second byte of data .\" So for example, \"Turn on yourself 3 times!\" would translate to the following message : message_t message; message.type = NORMAL; message.data[0] = 2; // Turn on yourself... message.data[1] = 3; // ...3 times! message.crc = message_crc(&message); We can now write a simple program that will generate a random instruction : message_t instruction; int instructionID; int instructionParam; void makeInstruction() { // Creates an instruction to be given to the rookie instruction.type = NORMAL; instruction.data[0] = instructionID; instruction.data[1] = instructionParam; instruction.crc = message_crc(&instruction); } void generateInstruction() { // Gives an instruction to the rookie // Choses the instruction instructionID = (rand_hard() % 3) + 1; // Instructions have a specific number, from 1 to 3 // Depending on the instruction, generates a random parameter switch (instructionID) { case 1: // Rookie must show his war face ! (Turn on his led) instructionParam = 0; break; case 2: // Rookie must run x centimeters, then come back. instructionParam = 3 + (rand_hard() % 8); // Cm to be runned, from 3 to 10 break; case 3: // Rookie must turn around on himself x times. instructionParam = 1 + (rand_hard() % 3); // number of turns, from 1 to 3 break; } makeInstruction(); } Note Note how we put instruction , instructionID and instructionParam as global variables. It makes it possible to access them from anywhere in the code, though we must be careful with the way each part of the program manipulates them.","title":"Instructions"},{"location":"tutorials/tuto2.html#message-handling","text":"To handle communication, we need to define two functions. One (commonly named message_tx() ) will be called when sending a message, the other (commonly named message_rx() ) will be called when receiving a message. We also have to define a flag, which is a variable with value 0 or 1 describing the \"state\" of the robot. In our case, the instructionGiven flag tells wether or not an instruction has been given to the rookie. If its value is 0, the instructor should generate and send a new instruction. If it's 1, the instructor waits for the rookie to finish. int instructionGiven = 0; message_t* message_tx() { // This function returns the instruction to send to the rookie return &instruction; } void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie has finished executing his order and is ready for a new one. instructionGiven = 0; } Note Notice the two parameters of the message_rx function. They are mandatory to define the function, but of no use for the instructor.","title":"Message handling"},{"location":"tutorials/tuto2.html#setup-and-loop","text":"The setup function for the instructor is rather minimalistic, it's even empty in fact. The instructor does not care about anything except yelling orders repeatedly. In the loop function, we will either generate a new instruction or wait for the rookie. When generating a new instruction, the instructor will indicate the instruction chosen by turning on its LED with a specific color. When waiting, the instructor blinks yellow. void setup() { } void loop() { if (!instructionGiven) { // Gives an order. Blinks a specific color depending on the given order generateInstruction(); switch (instructionID) { case 1: set_color(RGB(1,0, 0)); // Blinks red break; case 2: set_color(RGB(0, 1, 0)); // Blinks green break; case 3: set_color(RGB(0, 0, 1)); // Blinks green to break; } delay(500); set_color(RGB(0,0,0)); instructionGiven = 1; // Changes the flag } else { // Waits for the rookie. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } } Note Even if the setup() function is empty, we must define it, as it must be passed to the kilo_start() function.","title":"Setup and loop"},{"location":"tutorials/tuto2.html#put-it-together","text":"The only thing left to do is to define the main function. kilo_message_tx and kilo_message_rx are system variables used to specify which function to call when sending/receiving a message. int main() { // initialize hardware kilo_init(); // Registers the function to call when sending a instruction kilo_message_tx = message_tx; // Registers the function to call when rookie says he is ready kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; }","title":"Put it together"},{"location":"tutorials/tuto2.html#rookies-program","text":"Most of the aspects of the rookie's program have already been seen in the instructor's program. In this section, we will only focus on the new things.","title":"Rookie's program"},{"location":"tutorials/tuto2.html#message-handling_1","text":"","title":"Message handling"},{"location":"tutorials/tuto2.html#sending-messages","text":"The rookie must only send a message to say that he is ready, so the message doesn't need to contain any data : the mere fact that he is sending a message already tells the purpose of the message. And as you can see above, the instructor never cares about the content of the message. The rookie will also use a flag to tell wether he is ready for an instruction or not. These facts give the following code : #include <stddef.h> // Defines 'NULL' macro message_t ready; int waitingForInstruction = 0; void setup() { // Waits to be called by the instructor waitingForInstruction = 1; // Initialize the message ready.type = NORMAL; ready.crc = message_crc(&ready); } message_t* message_tx() { // Sends a message if the rookie is ready. If not, sends nothing. if (waitingForInstruction) { return &ready; } return NULL; }","title":"Sending messages"},{"location":"tutorials/tuto2.html#receiving-messages","text":"As for the instructor's program, the rookie will receive message with the message_rx() function. Here, the msg parameter is useful to retrieve the content of the message : int instructionID = 0; int instructionParam = 0; void message_rx(message_t *msg, distance_measurement_t *dist) { // This function is called when the rookie receives an instruction instructionID = msg->data[0]; instructionParam = msg->data[1]; waitingForInstruction = 0; }","title":"Receiving messages"},{"location":"tutorials/tuto2.html#the-loop","text":"In the loop function, the rookie will either execute an instruction, or wait to receive one. When waiting, it blinks yellow. int straightSpeedCalibrator = 1000; // Delay in milliseconds to go straight on 1cm int turningSpeedCalibrator = 5000; // Delay in milliseconds to make 1 turn around void loop() { if (waitingForInstruction) { // Waits for orders. Blinks yellow delay(500); set_color(RGB(1,1,0)); delay(500); set_color(RGB(0,0,0)); } else { switch(instructionID) { case 1: // Rookie shows his war face set_color(RGB(0, 1, 1)); delay(500); set_color(RGB(0,0,0)); break; case 2: // Rookie runs x centimeters, then comes back for (int i = 0 ; i < 2 ; i++) { spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); delay(instructionParam * straightSpeedCalibrator); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; case 3: // Rookie turns around on himself x times for (int i = 0 ; i < instructionParam ; i++) { spinup_motors(); set_motors(kilo_turn_left, 0); delay(turningSpeedCalibrator); set_motors(0, 0); } break; } waitingForInstruction = 1; delay(2000); // Waits two seconds before executing the next instruction } } Note Notice the use of straightSpeedCalibrator and turningSpeedCalibrator . These variables are used to indicate the time the kilobot takes to do a specific movement. Set them to the most fitting values depending on your kilobot specificities.","title":"The loop"},{"location":"tutorials/tuto2.html#put-it-together_1","text":"The main() function is nothing new at this point: int main() { // Initializes hardware kilo_init(); // Registers the function to call when receiving a instruction kilo_message_rx = message_rx; // Registers the function to call when sending a message kilo_message_tx = message_tx; // Starts program kilo_start(setup, loop); return 0; }","title":"Put it together"},{"location":"tutorials/tuto2.html#we-are-done","text":"You can now admire two kilobots in a tough military training. You've mastered the art of communication and are ready to get into the next tutorial !","title":"We are done !"},{"location":"tutorials/tuto3.html","text":"King-o-bot's Games source code of this tutorial Summary By now you should have mastered the movement and communication abilities of kilobots. However, there is one last sensing ability you have yet to discover : distance sensing. Kilobots can evaluate their distance from another kilobot when they receive a message : that's the purpose of the message_rx() function's second argument. In this simple tutorial, we are going to put two kilobots one in front of the other. As medieval knights, they will charge the other. However, the kilobots are really fearful and, when they will reach their personal distance limit, they will freak out and give up. What you will learn How to evaluate distance with the distance_measurement_t argument and estimate_distance() More complex state management Knight's program Defining macros and global variables To make our program more configurable and readable, we are going to use C macros . The first two macros are used to define boundaries for the kilobot's distance limit. The four following macros define the kilobot's state. #define MIN_DISTANCE 35 #define MAX_DISTANCE 70 #define CHARGING 0 #define FREAKING_OUT 1 #define WON 2 #define LOST 3 Our program will also use 3 global variables. One will contain the kilobot's distance limit, the second contains its state and the last one is used for storing messages. int distanceLimit; int state; message_t message; The setup() function Here we define the kilobot's custom distance limit using rand_hard() . We set the initial state : at the beginning, the two kilobots are charging . When communicating, the kilobot will send its state in data , so that the other kilobot know when its opponent freaks out. Finally, we set the color to an aggressive red and make the kilobot run forward. void setup() { // Set the distance limit. distanceLimit = (rand_hard() % (MAX_DISTANCE - MIN_DISTANCE)) + MIN_DISTANCE; // Set the state state = CHARGING; // Set the message message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); // Set light and movement set_color(RGB(3, 0, 0)); spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); } Note We defined MIN_DISTANCE and MAX_DISTANCE to be 35 and 70 millimeters respectively. This means that distanceLimit will always be between those two values. Communications Now this is the big part of this tutorial. The message_tx() function is quite classic know : message_t* message_tx() { return &message; } The message_rx() function however, is where the magic happens. Here, we analyse the state of the opponent and its distance from us. If the opponent is still charging and is closer than our distance limit, we start to freak out and surrender. If the opponent is freaking out on the other hand, we win and stop moving. void message_rx(message_t *m, distance_measurement_t *d) { if (state == CHARGING && m->data[0] == CHARGING) { // The kilobot and his opponent are still charging each other if (estimate_distance(d) < distanceLimit) { // The kilobot freaks out and surrender state = FREAKING_OUT; // Change message message.data[0] = state; message.crc = message_crc(&message); // Change movement spinup_motors(); set_motors(0, kilo_turn_right); } } else if (m->data[0]) { // The oponnent is freaking out state = WON; // Stop charging spinup_motors(); set_motors(0, 0); } } Here you can see how measuring distance is easy. We only need to pass the second argument of message_rx() to estimate_distance() . The result is an approximation of the distance between the two kilobots in millimeters. It can be stored as an int and compared with the distanceLimit we have defined earlier. The loop() function The loop() function will take care of the kilobot's shown behavior depending on its state. void loop() { if (state == CHARGING) { // The kilobot is charging : blink red set_color(RGB(3, 0, 0)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } else if (state == FREAKING_OUT) { // The kilobot is freaking out : quickly blink white for 2 seconds for (int i = 0 ; i < 2000 ; i += 200) { set_color(RGB(3, 3, 3)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } // The kilobot is calming down, he lost set_motors(0, 0); state = LOST; } else if (state == WON) { // The kilobot won the fight : blink blue, green and yellow set_color(RGB(0, 0, 3)); delay(100); set_color(RGB(0, 3, 0)); delay(100); set_color(RGB(3, 3, 0)); delay(100); } else { // The kilobot lost the fight : slowly, shamefully blinks white set_color(RGB(1, 1, 1)); delay(2000); set_color(RGB(0, 0, 0)); delay(2000); } } Put it all together Once again, nothing new in the main() function : int main() { kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; kilo_start(setup, loop); return 0; } We are done ! You can now make impressive and quite shocking kilobots duels ! Place them in front of each other, start and watch them charge... until one freaks out. You have mastered distance sensing and are now ready to code some complex programs for kilobots. It's now time to implement collective behaviors with a bigger number of kilobots.","title":"King-o-bot's Games"},{"location":"tutorials/tuto3.html#king-o-bots-games","text":"source code of this tutorial","title":"King-o-bot's Games"},{"location":"tutorials/tuto3.html#summary","text":"By now you should have mastered the movement and communication abilities of kilobots. However, there is one last sensing ability you have yet to discover : distance sensing. Kilobots can evaluate their distance from another kilobot when they receive a message : that's the purpose of the message_rx() function's second argument. In this simple tutorial, we are going to put two kilobots one in front of the other. As medieval knights, they will charge the other. However, the kilobots are really fearful and, when they will reach their personal distance limit, they will freak out and give up.","title":"Summary"},{"location":"tutorials/tuto3.html#what-you-will-learn","text":"How to evaluate distance with the distance_measurement_t argument and estimate_distance() More complex state management","title":"What you will learn"},{"location":"tutorials/tuto3.html#knights-program","text":"","title":"Knight's program"},{"location":"tutorials/tuto3.html#defining-macros-and-global-variables","text":"To make our program more configurable and readable, we are going to use C macros . The first two macros are used to define boundaries for the kilobot's distance limit. The four following macros define the kilobot's state. #define MIN_DISTANCE 35 #define MAX_DISTANCE 70 #define CHARGING 0 #define FREAKING_OUT 1 #define WON 2 #define LOST 3 Our program will also use 3 global variables. One will contain the kilobot's distance limit, the second contains its state and the last one is used for storing messages. int distanceLimit; int state; message_t message;","title":"Defining macros and global variables"},{"location":"tutorials/tuto3.html#the-setup-function","text":"Here we define the kilobot's custom distance limit using rand_hard() . We set the initial state : at the beginning, the two kilobots are charging . When communicating, the kilobot will send its state in data , so that the other kilobot know when its opponent freaks out. Finally, we set the color to an aggressive red and make the kilobot run forward. void setup() { // Set the distance limit. distanceLimit = (rand_hard() % (MAX_DISTANCE - MIN_DISTANCE)) + MIN_DISTANCE; // Set the state state = CHARGING; // Set the message message.type = NORMAL; message.data[0] = state; message.crc = message_crc(&message); // Set light and movement set_color(RGB(3, 0, 0)); spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); } Note We defined MIN_DISTANCE and MAX_DISTANCE to be 35 and 70 millimeters respectively. This means that distanceLimit will always be between those two values.","title":"The setup() function"},{"location":"tutorials/tuto3.html#communications","text":"Now this is the big part of this tutorial. The message_tx() function is quite classic know : message_t* message_tx() { return &message; } The message_rx() function however, is where the magic happens. Here, we analyse the state of the opponent and its distance from us. If the opponent is still charging and is closer than our distance limit, we start to freak out and surrender. If the opponent is freaking out on the other hand, we win and stop moving. void message_rx(message_t *m, distance_measurement_t *d) { if (state == CHARGING && m->data[0] == CHARGING) { // The kilobot and his opponent are still charging each other if (estimate_distance(d) < distanceLimit) { // The kilobot freaks out and surrender state = FREAKING_OUT; // Change message message.data[0] = state; message.crc = message_crc(&message); // Change movement spinup_motors(); set_motors(0, kilo_turn_right); } } else if (m->data[0]) { // The oponnent is freaking out state = WON; // Stop charging spinup_motors(); set_motors(0, 0); } } Here you can see how measuring distance is easy. We only need to pass the second argument of message_rx() to estimate_distance() . The result is an approximation of the distance between the two kilobots in millimeters. It can be stored as an int and compared with the distanceLimit we have defined earlier.","title":"Communications"},{"location":"tutorials/tuto3.html#the-loop-function","text":"The loop() function will take care of the kilobot's shown behavior depending on its state. void loop() { if (state == CHARGING) { // The kilobot is charging : blink red set_color(RGB(3, 0, 0)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } else if (state == FREAKING_OUT) { // The kilobot is freaking out : quickly blink white for 2 seconds for (int i = 0 ; i < 2000 ; i += 200) { set_color(RGB(3, 3, 3)); delay(100); set_color(RGB(0, 0, 0)); delay(100); } // The kilobot is calming down, he lost set_motors(0, 0); state = LOST; } else if (state == WON) { // The kilobot won the fight : blink blue, green and yellow set_color(RGB(0, 0, 3)); delay(100); set_color(RGB(0, 3, 0)); delay(100); set_color(RGB(3, 3, 0)); delay(100); } else { // The kilobot lost the fight : slowly, shamefully blinks white set_color(RGB(1, 1, 1)); delay(2000); set_color(RGB(0, 0, 0)); delay(2000); } }","title":"The loop() function"},{"location":"tutorials/tuto3.html#put-it-all-together","text":"Once again, nothing new in the main() function : int main() { kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; kilo_start(setup, loop); return 0; }","title":"Put it all together"},{"location":"tutorials/tuto3.html#we-are-done","text":"You can now make impressive and quite shocking kilobots duels ! Place them in front of each other, start and watch them charge... until one freaks out. You have mastered distance sensing and are now ready to code some complex programs for kilobots. It's now time to implement collective behaviors with a bigger number of kilobots.","title":"We are done !"},{"location":"tutorials/tuto4.html","text":"Morphogenetics source code of this tutorial Summary In most animals' bodies, some cells are able to feel their distance from other cells using chemicals propagation. The main use of this ability is to form complex shapes and tissues. The field of morphogenetic robotics takes inspiration from this to develop self-organized communities of robots. In this tutorial, we are going to develop a very simplified morphogenesis algorithm. It works with one 'source' kilobot and multiple 'cell' kilobots. Each 'cell' kilobot will be able to deduct its distance from the 'source' kilobot by communicating with its neighbors. The kilobots won't move, but they will use their LED to indicate their distance level. What you will learn How to implement a basic collective behavior Source's program The source kilobot is fairly simple. He will only send a message telling its level : 0. To recognize it from the other kilobots, we will set its LED to white. The setup() function message_t message; int level = 0; // 0 as this cell is the source void setup() { // Set message content message.type = NORMAL; message.data[0] = level; message.crc = message_crc(&message); // Set light set_color(RGB(3, 3, 3)); } Other functions As said above, the source kilobot really has nothing to do, so the loop() is just empty : void loop() { // Nothing to do } The message_tx() function is also quite common : message_t* message_tx() { return &message; } And once again, the main() function is nothing new : int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; } Cell's program Here's the tough part of the tutorial. Just as the source, the cells will communicate their current level with their neighbors. However, if a cell receive a message from a cell with a level 2 or more times lower than its own, it must update its level. Macros, message and setup() For a better configurability, we will define the MAX_LEVEL and TIMEOUT macros. MAX_LEVEL is the maximum distance level of all cells. TIMEOUT is used to know when to increase the cell's level : if a cell has no news from another cell with a lower level for a long time, it must deduct that it is now further away from the source and update its level accordingly. The timer variable will measure the time since last contact with a lower-level cell. #define MAX_LEVEL 5 #define TIMEOUT 30 message_t message; int level = MAX_LEVEL; // The cell starts at MAX_LEVEL int timer = 0; void setup() { message.type = NORMAL; } Sending and receiving messages In message_rx() , the cell analyses messages from its neighbors. If one of its neighbors' level is 2 or more times lower than its own level, it updates. If the level is just under its own, it resets its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (m->data[0] < level-1) { // Change level level = m->data[0] + 1; timer = 0; } if (m->data[0] == level-1) { // Reset timer timer = 0; } } In message_tx() , we update the message content with the current level just before sending the message : message_t* message_tx() { message.data[0] = level; message.crc = message_crc(&message); return &message; } The loop() function Every time we enter the loop() , we increase the timer. If it is above TIMEOUT , we decrement the cell's level. The cell will also display different shades from green to red depending on its level. void loop() { // Update timer timer++; if (timer >= TIMEOUT && level < MAX_LEVEL) { // Timeout level++; timer = 0; } // Set light switch (level) { case 1: set_color(RGB(0, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 3, 0)); delay(50); break; case 3: set_color(RGB(3, 3, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_LEVEL: set_color(RGB(3, 0, 0)); delay(50); break; } } Note As the TIMEOUT is set to 30 and the loop() takes 50 milliseconds to execute, a timeout take roughly 1,5 seconds to occur. Put it all together Don't forget the main() function! int main() { // initialize hardware kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; } We are done ! You can now play with the kilobots, moving them around. Try and see what happens when you change the location of the source kilobot. You can also play around with MAX_LEVEL and TIMEOUT , seeing the effects of each change. If you want to go further, why not make the source/cells move randomly? What happens when you have multiple 'source' kilobots? The possibilities are endless.","title":"Morphogenetics"},{"location":"tutorials/tuto4.html#morphogenetics","text":"source code of this tutorial","title":"Morphogenetics"},{"location":"tutorials/tuto4.html#summary","text":"In most animals' bodies, some cells are able to feel their distance from other cells using chemicals propagation. The main use of this ability is to form complex shapes and tissues. The field of morphogenetic robotics takes inspiration from this to develop self-organized communities of robots. In this tutorial, we are going to develop a very simplified morphogenesis algorithm. It works with one 'source' kilobot and multiple 'cell' kilobots. Each 'cell' kilobot will be able to deduct its distance from the 'source' kilobot by communicating with its neighbors. The kilobots won't move, but they will use their LED to indicate their distance level.","title":"Summary"},{"location":"tutorials/tuto4.html#what-you-will-learn","text":"How to implement a basic collective behavior","title":"What you will learn"},{"location":"tutorials/tuto4.html#sources-program","text":"The source kilobot is fairly simple. He will only send a message telling its level : 0. To recognize it from the other kilobots, we will set its LED to white.","title":"Source's program"},{"location":"tutorials/tuto4.html#the-setup-function","text":"message_t message; int level = 0; // 0 as this cell is the source void setup() { // Set message content message.type = NORMAL; message.data[0] = level; message.crc = message_crc(&message); // Set light set_color(RGB(3, 3, 3)); }","title":"The setup() function"},{"location":"tutorials/tuto4.html#other-functions","text":"As said above, the source kilobot really has nothing to do, so the loop() is just empty : void loop() { // Nothing to do } The message_tx() function is also quite common : message_t* message_tx() { return &message; } And once again, the main() function is nothing new : int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; }","title":"Other functions"},{"location":"tutorials/tuto4.html#cells-program","text":"Here's the tough part of the tutorial. Just as the source, the cells will communicate their current level with their neighbors. However, if a cell receive a message from a cell with a level 2 or more times lower than its own, it must update its level.","title":"Cell's program"},{"location":"tutorials/tuto4.html#macros-message-and-setup","text":"For a better configurability, we will define the MAX_LEVEL and TIMEOUT macros. MAX_LEVEL is the maximum distance level of all cells. TIMEOUT is used to know when to increase the cell's level : if a cell has no news from another cell with a lower level for a long time, it must deduct that it is now further away from the source and update its level accordingly. The timer variable will measure the time since last contact with a lower-level cell. #define MAX_LEVEL 5 #define TIMEOUT 30 message_t message; int level = MAX_LEVEL; // The cell starts at MAX_LEVEL int timer = 0; void setup() { message.type = NORMAL; }","title":"Macros, message and setup()"},{"location":"tutorials/tuto4.html#sending-and-receiving-messages","text":"In message_rx() , the cell analyses messages from its neighbors. If one of its neighbors' level is 2 or more times lower than its own level, it updates. If the level is just under its own, it resets its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (m->data[0] < level-1) { // Change level level = m->data[0] + 1; timer = 0; } if (m->data[0] == level-1) { // Reset timer timer = 0; } } In message_tx() , we update the message content with the current level just before sending the message : message_t* message_tx() { message.data[0] = level; message.crc = message_crc(&message); return &message; }","title":"Sending and receiving messages"},{"location":"tutorials/tuto4.html#the-loop-function","text":"Every time we enter the loop() , we increase the timer. If it is above TIMEOUT , we decrement the cell's level. The cell will also display different shades from green to red depending on its level. void loop() { // Update timer timer++; if (timer >= TIMEOUT && level < MAX_LEVEL) { // Timeout level++; timer = 0; } // Set light switch (level) { case 1: set_color(RGB(0, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 3, 0)); delay(50); break; case 3: set_color(RGB(3, 3, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_LEVEL: set_color(RGB(3, 0, 0)); delay(50); break; } } Note As the TIMEOUT is set to 30 and the loop() takes 50 milliseconds to execute, a timeout take roughly 1,5 seconds to occur.","title":"The loop() function"},{"location":"tutorials/tuto4.html#put-it-all-together","text":"Don't forget the main() function! int main() { // initialize hardware kilo_init(); kilo_message_rx = message_rx; kilo_message_tx = message_tx; // start program kilo_start(setup, loop); return 0; }","title":"Put it all together"},{"location":"tutorials/tuto4.html#we-are-done","text":"You can now play with the kilobots, moving them around. Try and see what happens when you change the location of the source kilobot. You can also play around with MAX_LEVEL and TIMEOUT , seeing the effects of each change. If you want to go further, why not make the source/cells move randomly? What happens when you have multiple 'source' kilobots? The possibilities are endless.","title":"We are done !"},{"location":"tutorials/tuto5.html","text":"Rush Hour source code of this tutorial Summary Here we are! This is the last tutorial of this guide. It's now time to wrap up everything we have learnt in one program. In this tutorial, a great number of kilobots will move around randomly. They will communicate with their neighbors, trying to count how many they are. If the kilobot has none or few neighbors, it will turn its LED green . If it has a lot of neighbors on the other hand, it will turn red . The goal is to produce a heat-map of some kind, where red regions correlate with a high kilobot density and green region with a low kilobot density. What you will learn How to use kilo_ticks How to use kilo_uid Summarize everything we have learnt through this guide Probe's program Each kilobot will run the same program : probe.c . The goal of the program is to register up to 5 neighbors and change LED accordingly. Macros Our program will define the following macros : #define TIMEOUT 50 #define MAX_DIST 100 #define MAX_NEIGHBOUR_NB 5 The goal of each macro will be clarified later in this tutorial. kilo_uid and structures During calibration, you can give each kilobot a unique ID . This ID is stored in the kilobot memory and can be accessed via the kilo_uid variable. In this tutorial, we will use it to differentiate every neighbor. Note Be sure to give each kilobot a unique ID at calibration. If two kilobots have the same ID, the final collective behavior will be altered. Each kilobot must also be able to forget a neighbor once it hasn't had contact with it for some time. To do so, we are going to define a structure : struct kilobot { int uid; int timer; }; This C structure stores the neighbor unique ID and the elapsed time since the last contact. To store the information of all neighbors, we can create an array of structures : struct kilobot neighbours[MAX_NEIGHBOUR_NB]; int nb_neighbours = 0; You can easily deduct the role of MAX_NEIGHBOUR_NB : it tells how many neighbors can be stored at the same time. The nb_neighbours variable will be used in two ways at the same time. The first way is to know how many neighbors are registered. The second is to know at which index to write in the neighbours array when registering a new neighbor. (If there are 3 neighbors, the following neighbor must be registered at index 3.) See if a neighbor is already registered When it receives a message, the kilobot must be able to know if it comes from a known neighbor or a new one. If it comes from a known neighbor, it must know at which index to find this neighbor in the neighbours array. This is what this simple algorithm does : int idOfNeighbour(int uid) { /* Looks for kilobot with 'uid' as uid in neighbours. If the kilobot exists, return its index in neighbours. Else, return -1. */ for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].uid == uid) { return i; } } return -1; } Message and setup() The only data we need to send to our neighbors is our unique ID ( kilo_uid ). We can therefore define the message in setup() , knowing it won't change during the execution. As usual, message_tx() does nothing extraordinary. message_t message; void setup() { // Set message content message.type = NORMAL; message.data[0] = kilo_uid; message.crc = message_crc(&message); } message_t* message_tx() { return &message; } The message_rx() function This function is a bit more complicated. First we must see if the kilobot sending the message is close enough to consider it a neighbor. This is the goal of the MAX_DIST macro : it tells the maximum distance for a kilobot to be considered a neighbor. Then we can use the function we defined previously to know if the kilobot sending the message is already registered in neighbours . If it is not, we register it (assuming we have an available index in neighbours ). If it is, we reset its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (estimate_distance(d) < MAX_DIST) { // The kilobot is close enough int id = idOfNeighbour(m->data[0]); if (id == -1) { // New neighbour, not yet registered if (nb_neighbours < MAX_NEIGHBOUR_NB) { // Can register it neighbours[nb_neighbours].uid = m->data[0]; neighbours[nb_neighbours].timer = 0; nb_neighbours++; } } else { // Neighbour already registered neighbours[id].timer = 0; } } } The loop() function The loop() function has quite a few things to do. First, it increments all of our neighbors' timer . // Increment timer of each kilobot for (int i = 0 ; i < nb_neighbours ; i++) { neighbours[i].timer++; } Second, it checks for neighbors in timeout . This is the goal of the TIMEOUT macro : it tells the limit for a neighbor's timer to be considered too big. If a kilobot is in timeout, we use a simple algorithm to shift all following neighbors to the left in neighbours and decrement nb_neighbours . This way, nb_neighbours still represents the number of neighbors and the index where we can register a new neighbor at the same time. // Check for kilobot timeout for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].timer >= TIMEOUT) { // Timeout. Remove this kilobot for (int j = i ; j < nb_neighbours-1 ; j++) { neighbours[j] = neighbours[j+1]; } nb_neighbours--; } } Here is where we set the LED to a shade between green and red depending on nb_neighbours : // Set light switch (nb_neighbours) { case 0: set_color(RGB(0, 3, 0)); delay(50); break; case 1: set_color(RGB(1, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 2, 0)); delay(50); break; case 3: set_color(RGB(2, 1, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_NEIGHBOUR_NB: set_color(RGB(3, 0, 0)); delay(50); break; } We still have to make the kilobots move randomly . We want each kilobot to chose a movement between \"straight\", \"turn left\" and \"turn right\" and execute it for one second, every second. We can't really use delay() as it would slow down the loop() considerably, therefore slowing the timers of all neighbors. One solution is to use kilo_ticks . The kilo_ticks variable is used to know the time elapsed since the execution started. It is incremented roughly 32 times per second. By using the % operator, we can then execute a piece of code every second : // Set movement if (kilo_ticks % 32 == 0) { // Roughly every second switch (rand_hard() % 3) { // Choses randomly case 0: // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); break; case 1: // Turn right spinup_motors(); set_motors(0, kilo_turn_right); break; case 2: // Turn left spinup_motors(); set_motors(kilo_turn_left, 0); break; } } Put it all together ! You probably know the main() function by heart at this point. int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; } We are done ! This was by far the most complete and complex program of this guide. Congratulations on keeping up to this point. There are still a few minor functionalities of kilobots we have not covered, such as their ability to sense ambient light, measure their board temperature, indicate their voltage or the kilo_message_tx_success callback. You can learn about those in the kilolib documentation . Anyway, we hope this guide was of use. May you have a lot of fun coding for kilobot!","title":"Rush Hour"},{"location":"tutorials/tuto5.html#rush-hour","text":"source code of this tutorial","title":"Rush Hour"},{"location":"tutorials/tuto5.html#summary","text":"Here we are! This is the last tutorial of this guide. It's now time to wrap up everything we have learnt in one program. In this tutorial, a great number of kilobots will move around randomly. They will communicate with their neighbors, trying to count how many they are. If the kilobot has none or few neighbors, it will turn its LED green . If it has a lot of neighbors on the other hand, it will turn red . The goal is to produce a heat-map of some kind, where red regions correlate with a high kilobot density and green region with a low kilobot density.","title":"Summary"},{"location":"tutorials/tuto5.html#what-you-will-learn","text":"How to use kilo_ticks How to use kilo_uid Summarize everything we have learnt through this guide","title":"What you will learn"},{"location":"tutorials/tuto5.html#probes-program","text":"Each kilobot will run the same program : probe.c . The goal of the program is to register up to 5 neighbors and change LED accordingly.","title":"Probe's program"},{"location":"tutorials/tuto5.html#macros","text":"Our program will define the following macros : #define TIMEOUT 50 #define MAX_DIST 100 #define MAX_NEIGHBOUR_NB 5 The goal of each macro will be clarified later in this tutorial.","title":"Macros"},{"location":"tutorials/tuto5.html#kilo_uid-and-structures","text":"During calibration, you can give each kilobot a unique ID . This ID is stored in the kilobot memory and can be accessed via the kilo_uid variable. In this tutorial, we will use it to differentiate every neighbor. Note Be sure to give each kilobot a unique ID at calibration. If two kilobots have the same ID, the final collective behavior will be altered. Each kilobot must also be able to forget a neighbor once it hasn't had contact with it for some time. To do so, we are going to define a structure : struct kilobot { int uid; int timer; }; This C structure stores the neighbor unique ID and the elapsed time since the last contact. To store the information of all neighbors, we can create an array of structures : struct kilobot neighbours[MAX_NEIGHBOUR_NB]; int nb_neighbours = 0; You can easily deduct the role of MAX_NEIGHBOUR_NB : it tells how many neighbors can be stored at the same time. The nb_neighbours variable will be used in two ways at the same time. The first way is to know how many neighbors are registered. The second is to know at which index to write in the neighbours array when registering a new neighbor. (If there are 3 neighbors, the following neighbor must be registered at index 3.)","title":"kilo_uid and structures"},{"location":"tutorials/tuto5.html#see-if-a-neighbor-is-already-registered","text":"When it receives a message, the kilobot must be able to know if it comes from a known neighbor or a new one. If it comes from a known neighbor, it must know at which index to find this neighbor in the neighbours array. This is what this simple algorithm does : int idOfNeighbour(int uid) { /* Looks for kilobot with 'uid' as uid in neighbours. If the kilobot exists, return its index in neighbours. Else, return -1. */ for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].uid == uid) { return i; } } return -1; }","title":"See if a neighbor is already registered"},{"location":"tutorials/tuto5.html#message-and-setup","text":"The only data we need to send to our neighbors is our unique ID ( kilo_uid ). We can therefore define the message in setup() , knowing it won't change during the execution. As usual, message_tx() does nothing extraordinary. message_t message; void setup() { // Set message content message.type = NORMAL; message.data[0] = kilo_uid; message.crc = message_crc(&message); } message_t* message_tx() { return &message; }","title":"Message and setup()"},{"location":"tutorials/tuto5.html#the-message_rx-function","text":"This function is a bit more complicated. First we must see if the kilobot sending the message is close enough to consider it a neighbor. This is the goal of the MAX_DIST macro : it tells the maximum distance for a kilobot to be considered a neighbor. Then we can use the function we defined previously to know if the kilobot sending the message is already registered in neighbours . If it is not, we register it (assuming we have an available index in neighbours ). If it is, we reset its timer. void message_rx(message_t *m, distance_measurement_t *d) { if (estimate_distance(d) < MAX_DIST) { // The kilobot is close enough int id = idOfNeighbour(m->data[0]); if (id == -1) { // New neighbour, not yet registered if (nb_neighbours < MAX_NEIGHBOUR_NB) { // Can register it neighbours[nb_neighbours].uid = m->data[0]; neighbours[nb_neighbours].timer = 0; nb_neighbours++; } } else { // Neighbour already registered neighbours[id].timer = 0; } } }","title":"The message_rx() function"},{"location":"tutorials/tuto5.html#the-loop-function","text":"The loop() function has quite a few things to do. First, it increments all of our neighbors' timer . // Increment timer of each kilobot for (int i = 0 ; i < nb_neighbours ; i++) { neighbours[i].timer++; } Second, it checks for neighbors in timeout . This is the goal of the TIMEOUT macro : it tells the limit for a neighbor's timer to be considered too big. If a kilobot is in timeout, we use a simple algorithm to shift all following neighbors to the left in neighbours and decrement nb_neighbours . This way, nb_neighbours still represents the number of neighbors and the index where we can register a new neighbor at the same time. // Check for kilobot timeout for (int i = 0 ; i < nb_neighbours ; i++) { if (neighbours[i].timer >= TIMEOUT) { // Timeout. Remove this kilobot for (int j = i ; j < nb_neighbours-1 ; j++) { neighbours[j] = neighbours[j+1]; } nb_neighbours--; } } Here is where we set the LED to a shade between green and red depending on nb_neighbours : // Set light switch (nb_neighbours) { case 0: set_color(RGB(0, 3, 0)); delay(50); break; case 1: set_color(RGB(1, 3, 0)); delay(50); break; case 2: set_color(RGB(1, 2, 0)); delay(50); break; case 3: set_color(RGB(2, 1, 0)); delay(50); break; case 4: set_color(RGB(3, 1, 0)); delay(50); break; case MAX_NEIGHBOUR_NB: set_color(RGB(3, 0, 0)); delay(50); break; } We still have to make the kilobots move randomly . We want each kilobot to chose a movement between \"straight\", \"turn left\" and \"turn right\" and execute it for one second, every second. We can't really use delay() as it would slow down the loop() considerably, therefore slowing the timers of all neighbors. One solution is to use kilo_ticks . The kilo_ticks variable is used to know the time elapsed since the execution started. It is incremented roughly 32 times per second. By using the % operator, we can then execute a piece of code every second : // Set movement if (kilo_ticks % 32 == 0) { // Roughly every second switch (rand_hard() % 3) { // Choses randomly case 0: // Goes straight spinup_motors(); set_motors(kilo_straight_left, kilo_straight_right); break; case 1: // Turn right spinup_motors(); set_motors(0, kilo_turn_right); break; case 2: // Turn left spinup_motors(); set_motors(kilo_turn_left, 0); break; } }","title":"The loop() function"},{"location":"tutorials/tuto5.html#put-it-all-together","text":"You probably know the main() function by heart at this point. int main() { // initialize hardware kilo_init(); kilo_message_tx = message_tx; kilo_message_rx = message_rx; // start program kilo_start(setup, loop); return 0; }","title":"Put it all together !"},{"location":"tutorials/tuto5.html#we-are-done","text":"This was by far the most complete and complex program of this guide. Congratulations on keeping up to this point. There are still a few minor functionalities of kilobots we have not covered, such as their ability to sense ambient light, measure their board temperature, indicate their voltage or the kilo_message_tx_success callback. You can learn about those in the kilolib documentation . Anyway, we hope this guide was of use. May you have a lot of fun coding for kilobot!","title":"We are done !"}]}